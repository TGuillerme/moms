#' @title Generates fable plots
#'
#' @description Generates the plots for the fable. The R markdown compiler should name them as "<snippet_name>-<ID>.<type>"
#'
#' @param data the disparity data
#' @param metric the metric ID
#' @param what the name of the chain as given pas the code snippet generating the plots
#' @param plot.param the plot parameters
#'
#' @examples
#'
#' @seealso
#' 
#' @author Thomas Guillerme
#' @export

generate.fable.plot <- function(data, metric, what, plot.param) {

    # data = remove_05
    # metric = 1
    # what = "random"

    pool.data <- function(data, metric, what) {
        ## Extract the metric
        pooled_metric <- lapply(remove_05, function(X, metric) return(X[[metric]]), metric = metric)

        ## Extract the category
        get.category <- function(data, what) {
            ## Get the right categories
            categories <- grep(what, rownames(data))
            ## Add the random category (number 2)
            categories <- c(2, categories)
            ## Return a matrix
            return(sapply(categories, function(X, data) {return(data[X,])}, data = data))
        }

        ## Get the pooled data
        pooled_data <- lapply(pooled_metric, get.category, what = what)
        return(do.call(rbind, pooled_data))
    }






    ## Get the data
    pooled_data <- pool.data(data, metric = metric, what = what)

    empty.plot()
    add.lines()
    add.points()











    empty.plot <- function() {
        ## Plot margins
        par(bty = "n", mar = c(2,1,1,1))
        ## Plot size
        plot(NULL, ylim = range(1:n_metrics), pch = 19, xlim = c(-1,1), xlab = "", ylab = "", xaxt = "n", yaxt = "n")



        ## Adding lines
        abline(v = 0, lty = 2, col = "grey")
        ## Adding the y axis
        axis(2, at = 1:n_metrics, labels = names_metrics, las = 2)
        ## Adding the x axis
        if(!is.last) {
            axis(1, labels = FALSE, tick = TRUE, col.ticks = "white", col = "grey")
        }
    }

    add.points <- function(cent.tend, one_reduction, col) {
        ## Get the right values 
        points_to_add <- as.numeric(lapply(cent.tend, function(X, Y) return(X[Y]), Y = one_reduction))
        ## Plot the values
        points(x = points_to_add, y = 1:length(points_to_add), col = col, pch = 19)
    }

    add.lines <- function(CIs, one_reduction, col) {
        ## Number of quantiles
        quantiles_n <- nrow(CIs[[1]])
        ## Extract the values for y
        y_vals <- lapply(as.list(1:length(CIs)), function(X) rep(X, 2))
        ## Extract the values for x
        x_vals <- list()
        for(cis in 1:(quantiles_n/2)) {
            x_vals[[cis]] <- lapply(CIs, function(X, Y, cis, quantiles_n) return(X[(1:quantiles_n)[c(cis, quantiles_n-(cis-1))],Y]), Y = one_reduction, cis, quantiles_n)
        }
        ## Plotting all the lines
        for(one_metric in 1:length(CIs)) {
            for(cis in 1:(quantiles_n/2)) {
                lines(x_vals[[cis]][[one_metric]], y_vals[[one_metric]], col = col[one_metric], lty = (quantiles_n/2 - cis + 1), lwd = cis * 1.5)
            }
        }
    }


}

#' @title Plotting distribution by ID
#'
#' @description Plots one distribution for the fable following the plot ID
#'
#' @param plot.ID the number of the plot as generated by generate the R markdown compiler
#' @param path where the plots are generated by the compiler
#' @param chain the name of the chain as given pas the code snippet generating the plots
#' @param resolution the plot resolution in the fable
#' @param type the file type (e.g. ".png")
#'
#' @examples
#'
#' @seealso
#' 
#' @author Thomas Guillerme
#' @export
plot.id <- function(plot.ID, path = "fig.path", chain = "fable_results", resolution = 800, type = ".png") {
    knitr::include_graphics(path = paste0(opts_chunk$get(path), paste0(chain, "-", plot.ID, type)),
                            dpi = resolution)
}

#' @title Display p-value from test
#'
#' @description Displays the p-value and significance token in the fable from the tests
#'
#' @param metric.ID The ID of the metric (i.e. row number)
#' @param type "s" or "r" for "space distributions" or "rarefaction"
#' @param test.results a list containing the results for either "s" or "r" mentioned above
#'
#' @examples
#'
#' @seealso
#' 
#' @author Thomas Guillerme
#' @export
s.test <- function(metric.ID, type, test.results = list("s" = test_space05, "r" = test_raref05)) { 
    ## Select the results
    test_results <- test.results[[type]]
    ## Coerce the results into a data.frame
    print_results <- test_results[[metric.ID]][[1]]
    class(print_results) <- "data.frame"
    ## Rounding
    print_results <- as.matrix(round(print_results, digits = 3))
    ## White spaces
    rownames(print_results) <- c("f.", "res.")
    print_results <- ifelse(is.na(print_results), "", print_results)
    ## Add the tokens
    p_val <- as.numeric(print_results[1,5])
    if(p_val < 0.001) {
        # print_results <- cbind(print_results, c("***", ""))
        signif_token <- "***"
    } else {
        if(p_val < 0.01) {
            # print_results <- cbind(print_results, c("**", ""))
          signif_token <- "**"
        } else {
            if(p_val < 0.05) {
                # print_results <- cbind(print_results, c("*", ""))
              signif_token <- "*"
            } else {
                if(p_val < 0.1) {
                    # print_results <- cbind(print_results, c(".", ""))
                    signif_token <- "."
                } else {
                    # print_results <- cbind(print_results, c("", ""))
                    signif_token <- ""
                }
            }
        }
    }
    ## Display the results
    output <- paste("p = ", p_val, signif_token)
    return(noquote(output))
}