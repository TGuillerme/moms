---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy? "
author: "Thomas Guillerme, Mark Puttick, Ariel Marcy, Vera Weisbecker"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

# Supplementary material 2: empirical data

```{r header_empirical, echo = FALSE}
## Loading the packages
if(!require(devtools)) install.packages("devtools")
if(!require(knitr)) install.packages("knitr"); library(knitr)
if(!require(rmarkdown)) install.packages("rmarkdown"); library(rmarkdown)
if(!require(ape)) install.packages("ape"); library(ape)
if(!require(dispRity)) install.packages("dispRity"); library(dispRity)
if(!require(geomorph)) install.packages("geomorph"); library(geomorph)
if(packageVersion("dispRity") < "1.2.4") {
    ## dispRity must be above v1.2.3
    devtools::install_github("TGuillerme/dispRity"); library(dispRity)
}
if(!require(moms)) devtools::install_github("TGuillerme/moms"); library(moms)
## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 ylim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait",
                 ylab = "Trait",
                 cex = 1)
## Generating the default palette
default.palette <- function(n) {
    hues = seq(15, 375, length = n + 1)
    grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}
```

# Empirical data

## Creating the trait spaces

The following sections contains the methodology and the code to generate the six empirical trait-spaces analysed in the paper.
The protocol for creating each space is detailed below.

### Palaeontological (discrete) data

For the discrete morphological data, we calculated a distance matrix from the original discrete morphological matrices from @beck2014 and @wright2017 using the maximum observable distance [@lloyd2016, @lehmann2019] that we then ordinated using a classical multidimensional scaling (MDS; [@torgerson1965, gower1966, cailliez1983]) by adding a constant **c\*** to make the distances Euclidean ($d_{MORD} + c* = d_{Euclidean}; @cailliez1983).
This resulted in ***k*** eigenvectors for each matrix where ***k*** is equal to $n-1$ taxa. 

```{r load_claddis_empirical}
## Creating the trait-spaces
beck_traitspace <- Claddis.ordination("../data/raw/Beck2014.nex", distance = "MORD")
wright_traitspace <- Claddis.ordination("../data/raw/Wright2017.nex", distance = "MORD")
```

For both datasets we created two groups, the crown versus the stem mammals for @beck2014 and the crinoids occuring before and after the Ordovician-Silurian boundary (455-430 million years ago - Mya).

```{r group_claddis_empirical}
## Loading the tree from Beck and Lee 2014
beck_tree <- read.nexus("../data/raw/Beck2014.tre")

## Selecting the crown and stem mammals
groups_beck <- crown.stem(beck_tree)

## Adding the four stem mammals not in the tree
missing_stem <- rownames(beck_traitspace)[which(is.na(match(rownames(beck_traitspace), 
                                                            beck_tree$tip.label)))]
groups_beck$stem <- c(groups_beck$stem, missing_stem)

## Loading the first and last occurence data from Wright 2017
wright_ages <- read.csv("../data/raw/Wright2017.csv")

## Separating taxa that went extinct half way through the Ordovician-Silurian extinction (442.5 Mya)
groups_wright <- ifelse(wright_ages$LAD < 422.5, TRUE, FALSE)
groups_wright <- list(#"all" = as.character(wright_ages$species),
                      "before" = as.character(wright_ages$species[which(groups_wright)]),
                      "after" =  as.character(wright_ages$species[which(!groups_wright)]))

## Creating the dispRity objects
beck_traitspace <- custom.subsets(beck_traitspace, group = groups_beck)
wright_traitspace <- custom.subsets(wright_traitspace, group = groups_wright)

## Saving the data for the main analysis
palaeo <- list("beck" = beck_traitspace, "wright" = wright_traitspace)
save.results(palaeo)
```


### Geometric morphometric (landmark) data

For the continuous geometric morphometric data, we performed a generalised Procrustes analysis [@adams2013geomorph], using 2D [@marcy2016] or 3D @@@ landmark coordinates sets (with semi-landmarks, i.e. sliders).
We then ordinated the resulted Procrustes superimposed data using a principal component analysis [PCA; @hotelling1933] and divided the data into two groups for each dataset (see below and in the main text).

#### Marcy et al. 2016

```{r load_marcy_empirical}
## Read in TPS coordinates
tps_data <- readland.tps("../data/raw/Marcy2016.TPS", specID = "imageID", warnmsg = FALSE)

## Remove duplicated points for ventral crania semi-landmarks (artefact of the landmarking process)
tps_data <- tps_data[-c(1, 2, 26, 29, 30, 41, 42, 45, 46, 51, 58, 60, 61, 68, 69, 78, 79, 85), , ]

## Read in semilandmark definitions from Marcy et al 2016
sliders <- read.csv("../data/raw/Marcy2016.csv", header = TRUE, colClasses = "integer")

## Get the specimens names
sp_names <- strsplit(names(tps_data[1, 1, ]), "_")

## Find non-unique specimens (they have a suffix, i.e. 7 elements)
duplicated <- ifelse(unlist(lapply(sp_names, length)) == 7, TRUE, FALSE)

## Remove duplicated specimens
tps_data <- tps_data[, , !duplicated]
sp_names <- sp_names[!duplicated]
```
##### Groups

We divided the dataset from @marcy2016 into two groups corresponding to the two genera: *Thomomys* and *Megascapheus*.

```{r group_gmm_empirical}
## Selecting the generas (first element in the name list)
subgenera <- unlist(lapply(sp_names, function(x) x[[1]]))

## Renaming the generas
subgenera <- as.factor(ifelse(subgenera == "T", "Thomomys", "Megascapheus"))

## Running the Procrustes superimposition
marcy_data <- geomorph.data.frame(gpagen(tps_data, Proj = TRUE, ProcD = TRUE, curves = sliders,
                                         print.progress = FALSE),
                                  subgenera)
```



```{r morphospace_gmm_empirical, eval = TRUE}
## Creating the trait space
marcy_traitspace <- dispRity::geomorph.ordination(marcy_data)

## Saving the data for the main analysis
gmm <- list("marcy" = marcy_traitspace, "noname" = marcy_traitspace)
save.results(gmm)
```

### Ecological (continuous) data

#### Jones et al. 2015 data

For the @jones2015 dataset, we converted the spreadsheet "aspen & grass richness & abund" from the data from @jones2015 available at @jones2015data into a .csv file (now available in `/data/raw`).
We then selected only the `wholeplot` entries and separated the studied plot between `aspen` and `grassland` and converted the species presence data into a presence/absence matrix.
From this matrix we calculated a Jaccard distance matrix [@oksanen2007vegan] that we then ordinated using a classical multidimensional scaling (MDS; [@torgerson1965, cailliez1983]) by adding a constant **c\*** to make the distances Euclidean ($d_{MORD} + c* = d_{Euclidean}; @cailliez1983).
This resulted in ***k*** eigenvectors for each matrix where ***k*** is equal to $n-1$ field sites. 

```{r load_jones_empirical, eval = TRUE}
## Reading the community composition data from Jones et al 2015
jones_communities <- read.csv("../data/raw/Jones2015.csv", stringsAsFactors = FALSE)

## Selecting only the whole plots and the plot number, habitat and species
jones_whole_com <- jones_communities[which(jones_communities$mptype == "wholeplot"), c(1,2,3)]

## Separate each plot into aspen/grassland
jones_whole_com$plot <- paste(jones_whole_com[,1], jones_whole_com$habitat, sep = ".")

## Making the community matrix
plot_names <- unique(jones_whole_com$plot)
sp_codes <- unique(jones_whole_com$species.code)
community <- matrix(NA, nrow = length(plot_names),
                        ncol = length(sp_codes),
                        dimnames = list(plot_names, sp_codes))

## Populate the matrix
for(one_plot in rownames(community)) {
    ## Get the community composition
    composition <- match(colnames(community),
                        jones_whole_com[which(jones_whole_com$plot == one_plot), 3])
    ## Fill the plot row with presence/absence data
    community[which(rownames(community) == one_plot), ] <- ifelse(is.na(composition), 0, 1)
}

## Calculate the distance matrix
distance_matrix <- as.matrix(vegan::vegdist(community, method = "jaccard"))

## Ordinating the data
jones_ordination <- stats::cmdscale(distance_matrix,
                                    k = ncol(distance_matrix)- 1, add = TRUE)$points
```

### Making the ecological trait-space groups

We separated the @jones2015 dataset into `aspen` and `grassland` groups.

```{r group_jones_empirical, eval = TRUE}
## Making the groups
jones_groups <- list("aspen" = grep("aspen", rownames(jones_ordination)),
                     "grassland" = grep("grassland", rownames(jones_ordination)))

## Making the dispRity objects
jones_traitspace <- custom.subsets(jones_ordination, group = jones_groups)

## Saving the data for the main analysis
ecol <- list("jones" = jones_traitspace, "ecodata" = jones_traitspace)
save.results(ecol)
```


### Exporting the datasets for shiny

```{r demo_data_empirical}
## The list of datasets
demo_data <- c(palaeo, gmm, ecol)
save(demo_data, file = "../data/demo_data.rda")
```

# Running the disparity calculations

```{r metrics_list_empirical, echo = FALSE}
## Loading the list of metrics
source("list.of.metrics.R")
```

```{r running_empirical, echo = FALSE}
## Loading the data
trait_spaces <- demo_data

## Measuring space occupancy for all spaces and all metrics
apply.disparity <- function(space, metrics) {
    lapply(metrics, function(metric, space) dispRity(boot.matrix(space, bootstraps = 500), metric),
           space)
}
empirical_results <- lapply(trait_spaces, apply.disparity, metrics_list)

## Results list
save.results(empirical_results)
```


# References