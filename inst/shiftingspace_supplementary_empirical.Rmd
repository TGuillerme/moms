---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy? "
author: "Thomas Guillerme, Mark Puttick, Ariel Marcy, Vera Weisbecker"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

# Supplementary material 2: empirical data

```{r, echo = FALSE}
## Loading the packages
if(!require(devtools)) install.packages("devtools")
if(!require(knitr)) install.packages("knitr"); library(knitr)
if(!require(rmarkdown)) install.packages("rmarkdown"); library(rmarkdown)
if(!require(ape)) install.packages("ape"); library(ape)
if(!require(dispRity)) install.packages("dispRity"); library(dispRity)
if(packageVersion("dispRity") < "1.2.4") {
    ## dispRity must be above v1.2.3
    devtools::install_github("TGuillerme/dispRity"); library(dispRity)
}
if(!require(moms)) devtools::install_github("TGuillerme/moms"); library(moms)
## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 ylim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait",
                 ylab = "Trait",
                 cex = 1)
## Generating the default palette
default.palette <- function(n) {
    hues = seq(15, 375, length = n + 1)
    grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}
```

# Empirical data

## Creating the trait spaces

The following sections contains the methodology and the code to generate the six empirical trait-spaces analysed in the paper.
The protocol for creating each space is detailed below.

### Palaeontological (discrete) data

For the discrete morphological data, we calculated a distance matrix from the original discrete morphological matrices from @beck2014 and @wright2017 using the maximum observable distance [@lloyd2016, @lehmann2019] that we then ordinated using a classical multidimensional scaling (MDS; [@torgerson1965, gower1966, cailliez1983]) by adding a constant **c\*** to make the distances Euclidean ($d_{MORD} + c* = d_{Euclidean}; @cailliez1983).
This resulted in ***k*** eigenvectors for each matrix where ***k*** is equal to $n-1$ taxa. 

```{r}
## Creating the trait-spaces
beck_traitspace <- Claddis.ordination("../data/matrices/Beck2014.nex", distance = "MORD")
wright_traitspace <- Claddis.ordination("../data/matrices/Wright2017.nex", distance = "MORD")
```

For both datasets we created two groups, the crown versus the stem mammals for @beck2014 and the crinoids occuring before and after the Ordovician-Silurian boundary (455-430 million years ago - Mya).

```{r}
## Loading the tree from Beck and Lee 2014
beck_tree <- read.nexus("../data/groups/Beck2014.tre")

## Selecting the crown and stem mammals
groups_beck <- crown.stem(beck_tree)
# groups_beck <- unlist(list(list("all" = beck_tree$tip.label), groups_beck), recursive = FALSE)

## Loading the first and last occurence data from Wright 2017
wright_ages <- read.csv("../data/groups/Wright2017.csv")

## Separating taxa that went extinct half way through the Ordovician-Silurian extinction (442.5 Mya)
groups_wright <- ifelse(wright_ages$LAD < 422.5, TRUE, FALSE)
groups_wright <- list(#"all" = as.character(wright_ages$species),
                      "before" = as.character(wright_ages$species[which(groups_wright)]),
                      "after" =  as.character(wright_ages$species[which(!groups_wright)]))

## Creating the dispRity objects
beck_traitspace <- custom.subsets(beck_traitspace, group = groups_beck)
wright_traitspace <- custom.subsets(wright_traitspace, group = groups_wright)

## Saving the data for the main analysis
palaeo <- list("beck" = beck_traitspace, "wright" = wright_traitspace)
save.results(palaeo)
```


### Geometric morphometric (landmark) data

For the geometric morphometric data (landmark datasets) we used...

```{r, eval = FALSE}
## Using the geomorph package
if(!require(geomorph)) install.packages("geomorph"); library(geomorph)

## Loading the landmark data

## Performing a Procrustes superimposition
 <- geomorph::gpagen(plethodon$land, PrinAxes = FALSE, print.progress = FALSE)

## Ordinating the data
 <- geomorph.ordination()

```

```{r, eval = FALSE}
## Making the groups

## Saving the data for the main analysis
gmm <- list("beck" = beck_traitspace, "wright" = wright_traitspace)
save.results(gmm)
```

### Ecological (continuous) data

### Jones et al. 2015 data

For the @jones2015 dataset, we converted the spreadsheet "aspen & grass richness & abund" from the data from @jones2015 available at @jones2015data into a .csv file (now available in `/data/matrices`).
We then selected only the `wholeplot` entries and separated the studied plot between `aspen` and `grassland` and converted the species presence data into a presence/absence matrix.
From this matrix we calculated a Jaccard distance matrix [@oksanen2007vegan] that we then ordinated using a classical multidimensional scaling (MDS; [@torgerson1965, cailliez1983]) by adding a constant **c\*** to make the distances Euclidean ($d_{MORD} + c* = d_{Euclidean}; @cailliez1983).
This resulted in ***k*** eigenvectors for each matrix where ***k*** is equal to $n-1$ field sites. 

```{r, eval = TRUE}
## Reading the community composition data from Jones et al 2015
jones_communities <- read.csv("../data/matrices/Jones2015.csv")

## Selecting only the whole plots and the plot number, habitat and species
jones_whole_com <- jones_communities[which(jones_communities$mptype == "wholeplot"), c(1,2,3)]

## Separate each plot into aspen/grassland
jones_whole_com$plot <- paste(jones_whole_com$plot, jones_whole_com$habitat, sep = ".")

## Making the community matrix
plot_names <- unique(jones_whole_com$plot)
sp_codes <- unique(jones_whole_com$species.code)
community <- matrix(NA, nrow = length(plot_names),
                        ncol = length(sp_codes),
                        dimnames = list(plot_names, sp_codes))

## Populate the matrix
for(one_plot in rownames(community)) {
    ## Get the community composition
    composition <- match(colnames(community),
                        jones_whole_com[which(jones_whole_com$plot == one_plot), 3])
    ## Fill the plot row with presence/absence data
    community[which(rownames(community) == one_plot), ] <- ifelse(is.na(composition), 0, 1)
}

## Calculate the distance matrix
distance_matrix <- as.matrix(vegan::vegdist(community, method = "jaccard"))

## Ordinating the data
jones_traitspace <- stats::cmdscale(distance_matrix,
                                    k = ncol(distance_matrix)- 1, add = TRUE)$points
```

### Making the ecological trait-space groups

We separated the @jones2015 dataset into `aspen` and `grassland` groups.

```{r, eval = FALSE}
## Making the groups
jones_groups <- list("aspen" = grep("aspen", rownames(jones_traitspace)),
                     "grassland" = grep("grassland", rownames(jones_traitspace)))

## Making the dispRity objects
jones_traitspace <- custom.subsets(jones_traitspace, group = jones_groups)

## Saving the data for the main analysis
ecol <- list("jones" = jones_traitspace, "ecodata" = jones_traitspace)
save.results(ecol)
```

# References