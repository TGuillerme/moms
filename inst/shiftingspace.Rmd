---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy?"
author: "Thomas Guillerme, Mark Puttick, Vera Weisbecker"
bibliography: references.bib
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 6
    fig_height: 6
---

```{r header, echo = FALSE}
## Loading the packages
library(knitr)
library(ape)
library(dispRity)
library(moms)

## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 xlim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait 1",
                 ylab = "Trait 2",
                 cex = 1)
```

# Introduction

 * We will cite papers like this one [@disprity].

 * Disparity is used a lot since the 1990s [Definition blabla] and also in ecology
 * It is linked to funtional spaces in ecology (but not called disparity there)
 * Here we will try to approach both aspects (but more like macroevolution) by defining disparity as: "multidimensional trait-space occupancy".
 * In macroevolution, disparity is used to test hypothesis on how one or multiple groups occupy a morphospace (either through time or space or both)
 * It has been used to answer classical questions such as 1) does disparity of one group changes through time or in response to extinction or 2) do groups A and B have different disparity.

 * However, the problem is that it is unclear what is meant in these two questions: classically disparity has been measured as sum or product of ranges or variance.
 * This measures the "spread" of a group in a morphospace (the product of ranges is the hyper-rectangular volume) but many more aspects might be interesting to researchers.
 * For example, in 1) a group's disparity (e.g. sum of variance) might not change through time but it's density might (suggesting that the morphospace is more/less tightly packed); in 2) two groups's disparities (e.g. sum of ranges) might be different but they might be situated in the same region of the morphospace.
 * Here we are going to classify disparity metrics into two broad spatial occupancy categories that might change independently: the volume, the density and the position. All of them are a distribution of distance in the space (whether Euclidean, Manhattan or others) and are traditionally summarised into a central tendency (e.g. the **sum** of variances, the **mean** pairwise distance), etc...


## Disparity metrics

```{r fig_metrics_types, echo = FALSE, fig.height = 3, fig.width = 9, results = 'hide'}
set.seed(11)
## Plot space function (utility shortcut)
## The elements
elements <- 10

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)

## Graphical parameters
op <- par(mfrow = c(1,3), bty = "n")

## The volume
plot(trait_space, pch = defaults$pch, main = "A - Volume", xlab = "Trait 1", ylab = "Trait 2")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1)

## The density
plot(trait_space, pch = defaults$pch, main = "B - Density", xlab = "Trait 1", ylab = "")
## Plotting the pairwise lines
pair.line <- function(line, trait_space, defaults) {
    lines(x = trait_space[line,1], y = trait_space[line,2], col = defaults$col1)
}
apply(combn(1:elements, 2), 2, pair.line, trait_space, defaults)
points(trait_space, pch = defaults$pch)

## The position
plot(trait_space, pch = defaults$pch, main = "C - Position", xlab = "Trait 1", ylab = "")
## Plotting the center of the space
points(0,0, pch = 13, cex = 2)
arrows(x0 = 0, y0 = 0, x1 = trait_space[,1], y1 = trait_space[,2], code = 0, col = defaults$col1)
points(trait_space, pch = defaults$pch)

par(op)
```

#### 1. The volume

 * This type of metrics measures the spread of a group in the trait-space. In biological terms, the bigger this metric, the more a group achieved more extreme morphologies.
 * This can be typically the hyper-volume, ellispsoid volume, product of ranges or product of variance.

#### 2. The density

 * This type of metrics measures the "packness" of a group in the trait-space. In biological terms, the bigger this metric, the more different morphologies are (i.e. heterogeneous).
 * This can be typically the mean pairwise distance, median distance from centroid, etc.

#### 3. The position

 * This type of metrics measures where the group is in the morphospace, either relative to another group or relative to a fixed point in the morphospace. Biological interpretation depends on what the distance from is. If it's distance from the centre of the morphospace, the bigger the metric, the more "weird" specimens in a group are (i.e. the centre being the average morphology in an ordination).
 * This has been rarely used.



 * Of course, different metrics can represent multiple aspects of these three main "axis".
 * Also, multiple scenarios can be predicted in macroevolutionary process to change the morphospace (e.g. a mass extinction making the specimens with extreme characteristics go extinct (e.g. big mammals in the megafauna extinction))
 * In this paper, we look at the effect of each spatial transformation on the different types of broad category metrics.

 * Furthermore, multidimensional spaces are in essence... multidimensional (here we mean beyond our 3 physical dimensions).
 * This adds another layer of complexity because some spatial properties do not change linerarly with the number of dimensions, especially with ordination techniques (where dimensions are ranked).
 * We thus also look at the effect of dimensions on the metrics + whether they are sensitive to sample size or missing data.

<!-- * Finally, one other aspect can be comparing a group to another one  -->
<!-- TG: Should we add stuff about comparing groups to each other? I.e. how to distinguish two groups, see Effect_of_metric_on_space.Rmd  -->
 

# Methods

## Making shifting spaces

 * We generate a series of spaces following some specific transformations.

 * First we generate a space with *n* elements and *k* dimensions and a general distribution *D*

 * We then remove 50% of the elements in the space 

 * We then modify this space following these four scenarios
    1. Random: This represents a loss in diversity within the space (or gain).
    2. By limit: selectively removing the centre or the edges
    3. By displacement: selectively removing one or three corners
    4. By density: increasing or reducing density





```{r fig_reduce_space, echo = FALSE, fig.height = 12, fig.width = 8, results = 'hide'}
set.seed(42)
op <- par(mfrow = c(4,2), bty = "n")
## The elements
elements <- 300
## The amount to remove
remove <- 0.5

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)
## The original space
plot(trait_space, pch = 20, xlim = c(-3, 3), ylim = c(-3, 3),
     main = "A - Original space", xlab = "Trait 1", ylab = "Trait 2")

## The randomly removed space
random_rm <- reduce.space(trait_space, type = "random", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, random_rm, main = "B - Random removal", defaults)

## The limit removal
limit_rm <- reduce.space(trait_space, type = "limit", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, limit_rm, main = "C1 - Limit removal (minimal)", defaults)
plot.space(trait_space, !limit_rm, main = "C2 - Limit removal (maximal)", defaults)

## The displacement removal
displace_rm <- reduce.space(trait_space, type = "displacement", remove = 0.5)
## Moving the space to the upper right corner (positive)
plot.space(trait_space, displace_rm, main = "D1 - Displacement (positive)", defaults)
plot.space(trait_space, !displace_rm, main = "D2 - Displacement (negative)", defaults)

## The density removal
density_rm <- reduce.space(trait_space, type = "density", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, density_rm, main = "E1 - Density (higher)", defaults)
plot.space(trait_space, !density_rm, main = "E2 - Density (lower)", defaults)

## List of removals (for plotting the tables later)
typical_removal <- list(space = trait_space,
                        remove = list("random" = random_rm,
                                      "limit(min)" = limit_rm,
                                      "limit(max)" = !limit_rm,
                                      "displace(positive)" = displace_rm,
                                      "displace(negative)" = !displace_rm,
                                      "density(high)" = density_rm,
                                      "density(low)" = !density_rm))
```

 [TODO:]
  - Should the dimensions be independent? Correlated? Screed (i.e. with decreasing variance)
  - Should we change the distributions *D* or leave it always fixed (normal)


 * We then extrapolate these changes for different points
    * number of elements *n*: 10, 50, 100, 500, 1000
    * number of dimensions *k*: 10, 50, 100, 500, 1000

## What do the metrics measure?

 * Include fable with: 1) name of the metric, 2) broad category, 3) what they measure, 4) their formula.

#### Volume metrics

```{r volume_metrics_list, echo = FALSE}
## The list of volume metrics used
volume_metrics <- list("ellispoid.volume" = ellipse.volume,
                       #"convhull.volume" = convhull.volume,
                       "n.ball.volume" = n.ball.volume,
                       "prod.range" = c(prod, ranges),
                       "prod.variance" = c(prod, variances),
                       "sum.range" = c(sum, ranges),
                       "sum.variance" = c(sum, variances),
                       "diagonal" = diagonal)
```

```{r fable_metrics, fig.show='hide'}
library(knitr)
par(margin = c(0,0,0,0), bty = "n")
## The volume
plot(trait_space, pch = defaults$pch, main = "", xlab = "", ylab = "")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1, lwd = 10)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1, lwd = 10)

## The volume
plot(trait_space, pch = defaults$pch, main = "", xlab = "", ylab = "")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1, lwd = 10)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1, lwd = 10)

```

some text | base|lattice
:------|:-------------------------------:|-------------------------------:
Some metric | $H_{0}: \Theta_{0} = \Theta$ | `r include_graphics(paste0(opts_chunk$get("fig.path"), "fable_metrics-1.png"), dpi = 800)`
Some other metric | $H_{0}: \Theta_{0} = \Theta$ | `r include_graphics(paste0(opts_chunk$get("fig.path"), "fable_metrics-2.png"), dpi = 800)`
Some other metric | $H_{0}: \Theta_{0} = \Theta$ | `r t.test(rnorm(10), rnorm(10))$p.value`


#### Density metrics

```{r density_metrics_list, echo = FALSE}
## The list of volume density metrics
density_metrics <- list("med.eucl.pairwise.dist" = c(median, pairwise.dist),
                        "sum.eucl.pairwise.dist" = c(sum, pairwise.dist),
                        "med.mana.pairwise.dist" = list(c(median, pairwise.dist),
                                                          method = "manhattan"),
                        "med.man.pairwise.dist" = list(c(sum, pairwise.dist),
                                                         method = "manhattan"),
                        "med.eucl.centroids" = c(median, centroids),
                        "sum.eucl.centroids" = c(sum, centroids),
                        "med.mana.centroids" = list(c(median, centroids), method = "manhattan"),
                        "sum.mana.centroids" = list(c(sum, centroids), method = "manhattan"),
                        "minimum.span.tree" = span.tree.length)
```


#### Position metrics


```{r position_metrics_list, echo = FALSE}
## The list of volume density metrics
density_metrics <- list("med.eucl.dist.centre" = list(c(median, centroids), centre = 0),
                        "sum.eucl.dist.centre" = list(c(sum, centroids), centre = 0),
                        "med.mana.dist.centre" = list(c(median, centroids),
                                                        centre = 0, method = "manhattan"),
                        "sum.mana.dist.centre" = list(c(sum, centroids),
                                                        centre = 0, method = "manhattan"))
                        #"distance.from.prev" = "SPECIAL")
```



## How good ("resilient") are the metrics?

 * How are they effective to the number of specimens (sample size 1)
 * How are they effective to the number of dimensions (sample size 2) - curse of multidimensionality
 * How are they effective to missing data (gapiness)






In the end, the analysis should be a big GLM of

disparity ~ metric + reduction + dimensions + elements





# Results


```{r custom_substest, echo = FALSE}
set.seed(42)
## Space parameters
elements <- 300
distributions <- rnorm
dimensions <- 10

## Disruption parameters
remove <- 0.5

## Trait space
trait_space <- space.maker(elements, dimensions, distribution = distributions)
## Adding rownames
rownames(trait_space) <- 1:elements

## Removing elements
random <- reduce.space(trait_space, type = "random", remove = remove)
limits <- reduce.space(trait_space, type = "limit", remove = remove)
displa <- reduce.space(trait_space, type = "displacement", remove = remove)
densit <- reduce.space(trait_space, type = "density", remove = remove)

## Making the custom groups list
custom_groups <- list("all" = rownames(trait_space),
                      "random" = rownames(trait_space)[random],
                      "limits.min" = rownames(trait_space)[limits],
                      "limits.max" = rownames(trait_space)[!limits],
                      "displa.min" = rownames(trait_space)[displa],
                      "displa.max" = rownames(trait_space)[!displa],
                      "densit.min" = rownames(trait_space)[densit],
                      "densit.max" = rownames(trait_space)[!densit])

## Making the custom groups
reduced_space <- custom.subsets(trait_space, group = custom_groups)

## Measuring disparity
measured_disparity <- dispRity(reduced_space, metric = volume_metrics[[1]])

## Wrapping function for the disparity metrics
lapply.metric <- function(metric, space, verbose) {
    if(is.null(names(metric))) {
        ## If metrics is not a named list, no options needed
        return(dispRity(space, metric = metric, verbose = verbose))
    } else {
        ## Get the main elements arguments list
        args <- list("data" = space, "metric" = metric[[1]], "verbose" = verbose)
        ## Add the optional arguments to the list
        args <- c(args, metric[-1])
        ## Run dispRity
        return(do.call(dispRity,args))
    }
}

## Running the volumes
disparity_volumes <- lapply(volume_metrics, lapply.metric, space = reduced_space, verbose = FALSE)

## Naming the results
names(disparity_volumes) <- names(volume_metrics)

## Extracting the disparity values
results_matrix <- lapply(lapply(disparity_volumes, extract.dispRity), cbind)

## Scaling the results (baseline being "all")
scale.metric <- function(one_metric) {
    ## Get the centre (the observed disparity in for the full morphospace)
    centered <- apply(one_metric, 2, function(X) as.numeric(X) - as.numeric(X)[1])
    scaled <- apply(centered, 2, function(X) X/(max(abs(X))))
    return(scaled)
}

results_matrices <- lapply(results_matrix, scale.metric)

## Temporary distributions
medians <- lapply(results_matrices, function(x) apply(x, 1, median))
CIs <- lapply(results_matrices, function(x) apply(x, 1, quantile, prob = c(0.1, 0.2, 0.3, 0.4)))

## Plotting the results
plot.metrics(medians, CIs, col, space, remove_list, defaults)
```



## What do the metrics measure?




A Table with different metrics and the things tested: 1- What is it
capturing (size, position, density) 2- Effect of dimensionality 3-
Measuring the effect on tests

# Results


# Acknowledgments



# References