---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy?"
author: "Thomas Guillerme, Mark Puttick, Vera Weisbecker"
bibliography: references.bib
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 6
    fig_height: 6
---


```{r header, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}
## Repeatability note:
## This whole paper is entirely reproducible and compiles as a single document. The data, figures
## and tables are all generated through the code snippets in this file. Note that the first time
## that this paper is compiled, it will generate the data which will take some substantial time
## by running the shiftingspace_supplementary.Rmd file first (~30 minutes). Subsequent compilations
## will be much faster!

## Loading the packages
library(knitr)
library(ape)
library(dispRity)
library(moms)

## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 ylim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait",
                 ylab = "Trait",
                 cex = 1)
## Generating the default palette
default.palette <- function(n) {
    hues = seq(15, 375, length = n + 1)
    grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}

```

# Abstract

Analysis of the diversity of morphological shapes (aka disparity analysis) are now a common toolkit in macroevolution.
Disparity analysis are based on the analysis of a morphospace (i.e. a multidimensional space summarising all possible shapes achieved or not) and a disparity metric (or index) to measure the occupancy of a group of taxa in that morphospace.
Such analysis have been commonly used to look at how a group of taxa changes through time, relatively to another group or as a response to some event (e.g. mass extinction).

However, disparity metrics are not often thoroughly described and thus can have a nebulous mathematical meaning.
This can make interpretation of changes in disparity often unclear beyond "a change in multidimensional space occupancy".
In fact, different aspect of spatial occupancy can be of interest in different studies.
For example, some questions might focus in changes in the volume of the morphospace whilst some other might focus on the position of a group in the morphospace or its density (or all three together).

Here we propose a user friendly tool to Measure Occupancy in Multidimensional Spaces (moms) that allows to visualise numerical changes of many disparity metrics following space transformations (e.g. contraction, displacement, etc.) as well as visualising a 2D projection of the associated space changes.
This tool thus allows researchers to explore and visualise the properties of disparity metrics under various parameters.
Furthermore, we propose a thorough review of the behaviour of seven common and two new disparity metrics regarding various spacial properties (i.e. distribution, transformation, dimensionality).
As expected, we found that different metrics are more appropriated to be used in different disparity analysis.

# Introduction

 * We will cite papers like this one [@disprity].

 * Disparity is used a lot since the 1990s [Definition blabla] and also in ecology
 * It is linked to funtional spaces in ecology (but not called disparity there)
 * Here we will try to approach both aspects (but more like macroevolution) by defining disparity as: "multidimensional trait-space occupancy".
 * In macroevolution, disparity is used to test hypothesis on how one or multiple groups occupy a morphospace (either through time or space or both)
 * It has been used to answer classical questions such as 1) does disparity of one group changes through time or in response to extinction or 2) do groups A and B have different disparity.

 * However, the problem is that it is unclear what is meant in these two questions: classically disparity has been measured as sum or product of ranges or variance.
 * This measures the "spread" of a group in a morphospace (the product of ranges is the hyper-rectangular volume) but many more aspects might be interesting to researchers.
 * For example, in 1) a group's disparity (e.g. sum of variance) might not change through time but it's density might (suggesting that the morphospace is more/less tightly packed); in 2) two groups's disparities (e.g. sum of ranges) might be different but they might be situated in the same region of the morphospace.
 * Here we are going to classify disparity metrics into two broad spatial occupancy categories that might change independently: the volume, the density and the position. All of them are a distribution of distance in the space (whether Euclidean, Manhattan or others) and are traditionally summarised into a central tendency (e.g. the **sum** of variances, the **mean** pairwise distance), etc...


## Disparity metrics

```{r fig_metrics_types, echo = FALSE, fig.height = 3, fig.width = 9, results = 'hide'}
set.seed(11)
## Plot space function (utility shortcut)
## The elements
elements <- 10

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)

## Graphical parameters
op <- par(mfrow = c(1,3), bty = "n")

## The volume
plot(trait_space, pch = defaults$pch, main = "A - Volume", xlab = "Trait 1", ylab = "Trait 2")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1)

## The density
plot(trait_space, pch = defaults$pch, main = "B - Density", xlab = "Trait 1", ylab = "")
## Plotting the pairwise lines
pair.line <- function(line, trait_space, defaults) {
    lines(x = trait_space[line,1], y = trait_space[line,2], col = defaults$col1)
}
apply(combn(1:elements, 2), 2, pair.line, trait_space, defaults)
points(trait_space, pch = defaults$pch)

## The position
plot(trait_space, pch = defaults$pch, main = "C - Position", xlab = "Trait 1", ylab = "")
## Plotting the center of the space
points(0,0, pch = 13, cex = 2)
arrows(x0 = 0, y0 = 0, x1 = trait_space[,1], y1 = trait_space[,2], code = 0, col = defaults$col1)
points(trait_space, pch = defaults$pch)

par(op)
```

#### 1. The volume

 * This type of metrics measures the spread of a group in the trait-space. In biological terms, the bigger this metric, the more a group achieved more extreme morphologies.
 * This can be typically the hyper-volume, ellispsoid volume, product of ranges or product of variance.

#### 2. The density

 * This type of metrics measures the "packness" of a group in the trait-space. In biological terms, the bigger this metric, the more different morphologies are (i.e. heterogeneous).
 * This can be typically the mean pairwise distance, median distance from centroid, etc.

#### 3. The position

 * This type of metrics measures where the group is in the morphospace, either relative to another group or relative to a fixed point in the morphospace. Biological interpretation depends on what the distance from is. If it's distance from the centre of the morphospace, the bigger the metric, the more "weird" specimens in a group are (i.e. the centre being the average morphology in an ordination).
 * This has been rarely used.



 * Of course, different metrics can represent multiple aspects of these three main "axis".
 * Also, multiple scenarios can be predicted in macroevolutionary process to change the morphospace (e.g. a mass extinction making the specimens with extreme characteristics go extinct (e.g. big mammals in the megafauna extinction))
 * In this paper, we look at the effect of each spatial transformation on the different types of broad category metrics.

 * Furthermore, multidimensional spaces are in essence... multidimensional (here we mean beyond our 3 physical dimensions).
 * This adds another layer of complexity because some spatial properties do not change linerarly with the number of dimensions, especially with ordination techniques (where dimensions are ranked).
 * We thus also look at the effect of dimensions on the metrics + whether they are sensitive to sample size or missing data.

<!-- * Finally, one other aspect can be comparing a group to another one  -->
<!-- TG: Should we add stuff about comparing groups to each other? I.e. how to distinguish two groups, see Effect_of_metric_on_space.Rmd  -->
 

# Methods

## Generating spaces

We generated 7 spaces using the following parameters.
Each space is are then reduced to 3, 5, 10, 50, 100, 300 dimensions and 10, 50, 100, 500 elements resulting in 168 parameter combinations.

| space name | size | distribution(s)                | dimensions variance | correlation |
|------------|------|--------------------------------|---------------------|-------------|
|   Uniform  |300*2 | Uniform (min = -0.5, max = 0.5)| Constant            | none        |
|   Uniform  |300*50| Uniform                        | Constant            | none        |
|   Uniform  |300*50| Uniform                        | Constant            | Random (between 0.1 and 0.9) |
|    Normal  |300*2 | Normal  (mean = 0, sd = 1)     | Constant            | none        |
|    Normal  |300*50| Normal                         | Constant            | none        |
|    Normal  |300*50| Normal                         | Constant            | Random (between 0.1 and 0.9) |
|   Random   |300*50| Normal, Uniform, Lognormal (meanlog = 0, sdlog = 1)| Constant            | none        |
| PCA        |300*50| Normal                         | Lognormal           | none        |
| PCO        |300*50| Normal                         | Normal              | none        |


## Shifting spaces

We then reduced the removed 80%, 50% and 20% of elements for the 168 parameters combinations following these four methods (resulting in 2520 combinations of parameters and space shifts):

 * **Randomly:** by randomly removing 80%, 50% or 20% of elements.  Figure 2A.
  
 * **Limit:** by removing all elements with a distance from the centre (mean point) of the space lower or greater than a radius $\rho$ (where \$rho$ is selected such that 80%, 50% or 20% or elements are selected).  Figure 2B.

 * **Displacement:** by removing points similarly as above but using the distance from the furthest point from the centre (max point). Figure 2C.

 * **Density:** by removing any pairs of point with a distance $D$ from each other where (where $D$ is selected such that 80%, 50% or 20% or elements are selected). Figure 2D.

The algorithm to select $\rho$ or $D$ is described in more detail in in the [Appendix](#Appendix_algorithm_reduce).
We used mirror results for the limit, displacement and density reduction (i.e. the opposite data was also used).
For example, when using the limit reduction that includes 80% of the elements greater than $\rho$, we also used a limit reduction taht includes 20% of the elements lower than $\rho$.

This resulted in 3528 parameters.


```{r fig_reduce_space, echo = FALSE, fig.height = 8, fig.width = 8, results = 'hide'}
set.seed(42)
op <- par(mfrow = c(2,2), bty = "n")
## The elements
elements <- 300
## The amount to remove
remove <- 0.5

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)
# ## The original space
# plot(trait_space, pch = 20, xlim = c(-3, 3), ylim = c(-3, 3),
#      main = "A - Original space", xlab = "Trait 1", ylab = "Trait 2")

## The randomly removed space
random_rm <- reduce.space(trait_space, type = "random", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, random_rm, main = "A - Random removal", defaults)

## The limit removal
limit_rm <- reduce.space(trait_space, type = "limit", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, limit_rm, main = "B - Limit", defaults)

## The displacement removal
displace_rm <- reduce.space(trait_space, type = "displacement", remove = 0.5)
## Moving the space to the upper right corner (positive)
plot.space(trait_space, displace_rm, main = "C - Displacement", defaults)

## The density removal
density_rm <- reduce.space(trait_space, type = "density", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, density_rm, main = "D - Density", defaults)

## List of removals (for plotting the tables later)
typical_removal <- list(space = trait_space,
                        remove = list("random" = random_rm,
                                      "limit(min)" = limit_rm,
                                      "limit(max)" = !limit_rm,
                                      "displace(positive)" = displace_rm,
                                      "displace(negative)" = !displace_rm,
                                      "density(high)" = density_rm,
                                      "density(low)" = !density_rm))
```

We repeated each step (and the following disparity measurements) 15 times.


## What do the metrics measure?

 * Include fable with: 1) name of the metric, 2) broad category, 3) what they measure, 4) their formula.

#### Volume metrics

```{r fable_metrics, fig.show='hide', echo= FALSE, eval = FALSE}
library(knitr)
par(margin = c(0,0,0,0), bty = "n")
## The volume
plot(trait_space, pch = defaults$pch, main = "", xlab = "", ylab = "")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1, lwd = 10)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1, lwd = 10)

## The volume
plot(trait_space, pch = defaults$pch, main = "", xlab = "", ylab = "")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1, lwd = 10)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1, lwd = 10)

```

<!-- 
some text | base|lattice
:------|:-------------------------------:|-------------------------------:
Some metric | $H_{0}: \Theta_{0} = \Theta$ | `r include_graphics(paste0(opts_chunk$get("fig.path"), "fable_metrics-1.png"), dpi = 800)`
Some other metric | $H_{0}: \Theta_{0} = \Theta$ | `r include_graphics(paste0(opts_chunk$get("fig.path"), "fable_metrics-2.png"), dpi = 800)`
Some other metric | $H_{0}: \Theta_{0} = \Theta$ | `r t.test(rnorm(10), distributions = rnorm(10))$p.value`
 -->


#### Density metrics


#### Position metrics


```{r, all_metric, echo = FALSE}
## All metrics (exploration)
metrics_list <- list(
    "av.pairwise" = function(matrix) return(mean(pairwise.dist(matrix)^2)),
    "Procrustes" = function(matrix) return(sum(matrix^2)/nrow(matrix)),
    "Volume" = ellipse.volume,
    "PoR" = c(prod, ranges),
    "SoR" = c(sum, ranges),
    "PoV" = c(prod, variances),
    "SoV" = c(sum, variances),
    # "PoQ" = c(prod, quantiles),
    # "SoQ" = c(sum, quantiles),
    "av.displac" = c(mean, displacements),
    "av.neighbo" = c(mean, neighbours)
)

metric_names <- c("Average squared distance", "Procrustes variance", "Ellipsoid volume", 
                  "Product of Range", "Sum of Ranges", "Product of Variances", "Sum of Variances",
                  "Mean displacement", "Mean nearest neighbours distance")
## Shorter vector name version (for clarity in the fable)
name <- metric_names
#"Product of Quantiles", "Sum of Quantiles", 
```

```{r, complex_metrics_example, echo = FALSE, eval = FALSE}
complex_metric <- list("med.mana.dist.centre" = list(c(median, centroids),
                                                     centroid = 0, method = "manhattan"))
```

## Effect of dimensionality

Curse of dimensionality: the more the dimensions the more sparse the data becomes.

For example:

```{r fig_curse, echo = FALSE, fig.height = 8, fig.width = 8, results = 'hide'}
set.seed(42)
## Make a 50 dimensions space
space <- space.maker(300, 50, rnorm, scree = rev(cumsum(rep(1/50, 50))))

## Function wrappers
disparity <- function(metric, dimensions, space) {
    fast.disparity(group = 1:nrow(space), space = space, metric = metric, rare.dim = dimensions)
}
lapply.fun <- function(dimensions, metrics_list, space) {
  unlist(lapply(metrics_list, disparity, dimensions = dimensions, space = space))
}

## Curse results
curse_results <- sapply(2:50, lapply.fun, metrics_list = metrics_list, space = space)
curse_results <- apply(curse_results, 1, function(x) return(x/max(x)))

## Empty plot
hue_colors <- default.palette(ncol(curse_results))
par(bty = "n")
plot(NULL, xlim = c(2,50), ylim = c(0,1),
    xlab = "Dimensions (decreasing variance)",
    ylab = "Scaled disparity")
for(metric in 1:ncol(curse_results)) {
  lines(curse_results[, metric], col = hue_colors[metric])
}
legend("bottomleft", colnames(curse_results), lty = 1, col = hue_colors)
```











In the end, the analysis should be a big GLM of

disparity ~ metric + reduction + dimensions + elements



# Results

```{r loading_results, echo = FALSE}
## Loading the results
remove_05 <- load.results("remove_05")
rarefy_dim_05 <- load.results("rarefy_dim_05")

## Scale the results

```

```{r running_tests, echo = FALSE}
## Anova function
anova.fun <- function(data) {return(aov(glm(disparity ~ factor, data = data)))}

## Running the tests
test_space05 <- test.metrics(remove_05, test = anova.fun, scale = TRUE)
test_raref05 <- test.metrics(rarefy_dim_05, test = anova.fun, scale = TRUE)

#TODO: Generate the aov tables in the supplementary

```

```{r fable_results, fig.show='hide', echo= FALSE}
## Making a list of parameters for each mini plot
plot.param <- list(scaler = 5,
                   bg.col = "black",
                   col = c("grey", "orange", "blue"),
                   quantiles = c(95, 50),
                   cent.tend = median,
                   pch = 19)

## Looping through each mini plot for every metric
for(metric in 1:length(metrics_list)) {
    generate.fable.plot(data = remove_05, metric = metric, what = "limits", plot.param = plot.param)
    generate.fable.plot(data = remove_05, metric = metric, what = "displa", plot.param = plot.param)
    generate.fable.plot(data = remove_05, metric = metric, what = "densit", plot.param = plot.param)
}

```

Metric      | Volume change  | Position change | Density change | Distribution effect | Dimensions effect
:-----------|----------------|-----------------|----------------|---------------------|-------------------
`r name[1]` |`r plot.id(1)`  |`r plot.id(2)`   |`r plot.id(3)`  | `r s.test(1, "s")`  | `r s.test(1, "r")`
`r name[2]` |`r plot.id(4)`  |`r plot.id(5)`   |`r plot.id(6)`  | `r s.test(2, "s")`  | `r s.test(2, "r")`
`r name[3]` |`r plot.id(7)`  |`r plot.id(8)`   |`r plot.id(9)`  | `r s.test(3, "s")`  | `r s.test(3, "r")`
`r name[4]` |`r plot.id(10)` |`r plot.id(11)`  |`r plot.id(12)` | `r s.test(4, "s")`  | `r s.test(4, "r")`
`r name[5]` |`r plot.id(13)` |`r plot.id(14)`  |`r plot.id(15)` | `r s.test(5, "s")`  | `r s.test(5, "r")`
`r name[6]` |`r plot.id(16)` |`r plot.id(17)`  |`r plot.id(18)` | `r s.test(6, "s")`  | `r s.test(6, "r")`
`r name[7]` |`r plot.id(19)` |`r plot.id(20)`  |`r plot.id(21)` | `r s.test(7, "s")`  | `r s.test(7, "r")`
`r name[8]` |`r plot.id(22)` |`r plot.id(23)`  |`r plot.id(24)` | `r s.test(8, "s")`  | `r s.test(8, "r")`
`r name[9]` |`r plot.id(25)` |`r plot.id(26)`  |`r plot.id(27)` | `r s.test(9, "s")`  | `r s.test(9, "r")`


## Stats

Check whether a metric changes:

1 - By reduction (i.e. whether the resulting metric is positive or negative)
2 - By space (i.e. whether the metric is constant for different spaces)
3 - By dimensions (i.e. whether the metric is constant for different number of dimensions)



















<!-- ## Alternative plotting (per results) -->

```{r fig_volume_results_unif2d05, echo = FALSE, fig.height = 21, fig.width = 8, eval = FALSE}
results <- summar_all_runif2d05
## Plotting the results
plot.results(results[[1]], results[[2]], col = default.palette(length(results[[1]])),
             space = typical_removal[[1]], remove_list = typical_removal[[2]], defaults)
```





<!-- ```{r fig_density_results, echo = FALSE, fig.height = 10, fig.width = 8, eval = FALSE}
results <- summar_den
## Plotting the results
plot.results(results[[1]], results[[2]], col = default.palette(length(results[[1]])),
             space = typical_removal[[1]], remove_list = typical_removal[[2]], defaults)
```

```{r fig_position_results, echo = FALSE, fig.height = 10, fig.width = 8, eval = FALSE}
results <- summar_pos
## Plotting the results
plot.results(results[[1]], results[[2]], col = default.palette(length(summar_vol[[1]])),
             space = typical_removal[[1]], remove_list = typical_removal[[2]], defaults)
```
 -->


## What do the metrics measure?



A Table with different metrics and the things tested: 1- What is it
capturing (size, position, density) 2- Effect of dimensionality 3-
Measuring the effect on tests

# Results


# Acknowledgements

Money from the ARC.

# References



# Supplementary material

## Algorithm for selecting the parameters to reduce the space ($radius$, $displacement$, $density$) {#Appendix_algorithm_reduce}

We used a recursive algorithm for selecting the parameter that removes $P$ elements: 80%, 50% or 20%.

1. Select a random reduction parameters $R$.
2. Remove elements from the space using $R$ resulting in $P'$ removed elements.
    If the remaining number of elements is to the required proportion $P$ ; exit the algorithm;
    Else go to 3.
3. Get the different between the proportion of removed elements $P'$ and $P$.
    If the difference is positive set the increment parameter $R$ to $R = 1.1 \times R$, then go to 2.
    Else set $R = 0.9 \times R$, then go to 2.

The algorithm is implemented in the `optimise.parameter` function in [reduce.space_fun.R](@@@).

