---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy?"
author: "Thomas Guillerme, Mark Puttick, Vera Weisbecker"
bibliography: references.bib
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 6
    fig_height: 6
---

```{r header, echo = FALSE}
## Loading the packages
library(knitr)
library(ape)
library(dispRity)
library(moms)

## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 ylim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait",
                 ylab = "Trait",
                 cex = 1)
## Generating the default palette
default.palette <- function(n) {
    hues = seq(15, 375, length = n + 1)
    grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}

```

# Introduction

 * We will cite papers like this one [@disprity].

 * Disparity is used a lot since the 1990s [Definition blabla] and also in ecology
 * It is linked to funtional spaces in ecology (but not called disparity there)
 * Here we will try to approach both aspects (but more like macroevolution) by defining disparity as: "multidimensional trait-space occupancy".
 * In macroevolution, disparity is used to test hypothesis on how one or multiple groups occupy a morphospace (either through time or space or both)
 * It has been used to answer classical questions such as 1) does disparity of one group changes through time or in response to extinction or 2) do groups A and B have different disparity.

 * However, the problem is that it is unclear what is meant in these two questions: classically disparity has been measured as sum or product of ranges or variance.
 * This measures the "spread" of a group in a morphospace (the product of ranges is the hyper-rectangular volume) but many more aspects might be interesting to researchers.
 * For example, in 1) a group's disparity (e.g. sum of variance) might not change through time but it's density might (suggesting that the morphospace is more/less tightly packed); in 2) two groups's disparities (e.g. sum of ranges) might be different but they might be situated in the same region of the morphospace.
 * Here we are going to classify disparity metrics into two broad spatial occupancy categories that might change independently: the volume, the density and the position. All of them are a distribution of distance in the space (whether Euclidean, Manhattan or others) and are traditionally summarised into a central tendency (e.g. the **sum** of variances, the **mean** pairwise distance), etc...


## Disparity metrics

```{r fig_metrics_types, echo = FALSE, fig.height = 3, fig.width = 9, results = 'hide'}
set.seed(11)
## Plot space function (utility shortcut)
## The elements
elements <- 10

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)

## Graphical parameters
op <- par(mfrow = c(1,3), bty = "n")

## The volume
plot(trait_space, pch = defaults$pch, main = "A - Volume", xlab = "Trait 1", ylab = "Trait 2")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1)

## The density
plot(trait_space, pch = defaults$pch, main = "B - Density", xlab = "Trait 1", ylab = "")
## Plotting the pairwise lines
pair.line <- function(line, trait_space, defaults) {
    lines(x = trait_space[line,1], y = trait_space[line,2], col = defaults$col1)
}
apply(combn(1:elements, 2), 2, pair.line, trait_space, defaults)
points(trait_space, pch = defaults$pch)

## The position
plot(trait_space, pch = defaults$pch, main = "C - Position", xlab = "Trait 1", ylab = "")
## Plotting the center of the space
points(0,0, pch = 13, cex = 2)
arrows(x0 = 0, y0 = 0, x1 = trait_space[,1], y1 = trait_space[,2], code = 0, col = defaults$col1)
points(trait_space, pch = defaults$pch)

par(op)
```

#### 1. The volume

 * This type of metrics measures the spread of a group in the trait-space. In biological terms, the bigger this metric, the more a group achieved more extreme morphologies.
 * This can be typically the hyper-volume, ellispsoid volume, product of ranges or product of variance.

#### 2. The density

 * This type of metrics measures the "packness" of a group in the trait-space. In biological terms, the bigger this metric, the more different morphologies are (i.e. heterogeneous).
 * This can be typically the mean pairwise distance, median distance from centroid, etc.

#### 3. The position

 * This type of metrics measures where the group is in the morphospace, either relative to another group or relative to a fixed point in the morphospace. Biological interpretation depends on what the distance from is. If it's distance from the centre of the morphospace, the bigger the metric, the more "weird" specimens in a group are (i.e. the centre being the average morphology in an ordination).
 * This has been rarely used.



 * Of course, different metrics can represent multiple aspects of these three main "axis".
 * Also, multiple scenarios can be predicted in macroevolutionary process to change the morphospace (e.g. a mass extinction making the specimens with extreme characteristics go extinct (e.g. big mammals in the megafauna extinction))
 * In this paper, we look at the effect of each spatial transformation on the different types of broad category metrics.

 * Furthermore, multidimensional spaces are in essence... multidimensional (here we mean beyond our 3 physical dimensions).
 * This adds another layer of complexity because some spatial properties do not change linerarly with the number of dimensions, especially with ordination techniques (where dimensions are ranked).
 * We thus also look at the effect of dimensions on the metrics + whether they are sensitive to sample size or missing data.

<!-- * Finally, one other aspect can be comparing a group to another one  -->
<!-- TG: Should we add stuff about comparing groups to each other? I.e. how to distinguish two groups, see Effect_of_metric_on_space.Rmd  -->
 

# Methods

## Generating spaces

We generated 7 spaces using the following parameters.
Each space is are then reduced to 3, 5, 10, 50, 100, 300 dimensions and 10, 50, 100, 500 elements resulting in 168 parameter combinations.

| space name | size   | distribution(s) | dimensions variance | correlation |
|------------|--------|-----------------|---------------------|-------------|
| PCA        |300*50| Normal (mean = 0, sd = 1)| Decrease lognormally| none        |
| PCO        |300*50| Normal          | Decrease normally   | none        |
|    Normal  |300*50| Normal          | Constant            | none        |
| Normal correlated |300*50| Normal          | Constant            | Random (between 0.1 and 0.9) |
|   Uniform  |300*50| Uniform (min = -0.5, max = 0.5)| Constant            | none        |
|   Uniform  |300*50| Uniform         | Constant            | Random (between 0.1 and 0.9) |
|   Random   |300*50| Normal, Uniform, Lognormal (meanlog = 0, sdlog = 1)| Constant            | none        |


## Shifting spaces

We then reduced the removed 80%, 50% and 20% of elements for the 168 parameters combinations following these four methods (resulting in 2520 combinations of parameters and space shifts):

 * **Randomly:** by randomly removing 80%, 50% or 20% of elements.  Figure 2A.
  
 * **Limit:** by removing all elements with a distance from the centre (mean point) of the space lower or greater than a radius $\rho$ (where \$rho$ is selected such that 80%, 50% or 20% or elements are selected).  Figure 2B.

 * **Displacement:** by removing points similarly as above but using the distance from the furthest point from the centre (max point). Figure 2C.

 * **Density:** by removing any pairs of point with a distance $D$ from each other where (where $D$ is selected such that 80%, 50% or 20% or elements are selected). Figure 2D.

The algorithm to select $\rho$ or $D$ is described in more detail in in the [Appendix](#Appendix_algorithm_reduce).
We used mirror results for the limit, displacement and density reduction (i.e. the opposite data was also used).
For example, when using the limit reduction that includes 80% of the elements greater than $\rho$, we also used a limit reduction taht includes 20% of the elements lower than $\rho$.

This resulted in 3528 parameters.


```{r fig_reduce_space, echo = FALSE, fig.height = 8, fig.width = 8, results = 'hide'}
set.seed(42)
op <- par(mfrow = c(2,2), bty = "n")
## The elements
elements <- 300
## The amount to remove
remove <- 0.5

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)
# ## The original space
# plot(trait_space, pch = 20, xlim = c(-3, 3), ylim = c(-3, 3),
#      main = "A - Original space", xlab = "Trait 1", ylab = "Trait 2")

## The randomly removed space
random_rm <- reduce.space(trait_space, type = "random", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, random_rm, main = "A - Random removal", defaults)

## The limit removal
limit_rm <- reduce.space(trait_space, type = "limit", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, limit_rm, main = "B - Limit", defaults)

## The displacement removal
displace_rm <- reduce.space(trait_space, type = "displacement", remove = 0.5)
## Moving the space to the upper right corner (positive)
plot.space(trait_space, displace_rm, main = "C - Displacement", defaults)

## The density removal
density_rm <- reduce.space(trait_space, type = "density", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, density_rm, main = "D - Density", defaults)

## List of removals (for plotting the tables later)
typical_removal <- list(space = trait_space,
                        remove = list("random" = random_rm,
                                      "limit(min)" = limit_rm,
                                      "limit(max)" = !limit_rm,
                                      "displace(positive)" = displace_rm,
                                      "displace(negative)" = !displace_rm,
                                      "density(high)" = density_rm,
                                      "density(low)" = !density_rm))
```

We repeated each step (and the following disparity measurements) 15 times.


## What do the metrics measure?

 * Include fable with: 1) name of the metric, 2) broad category, 3) what they measure, 4) their formula.

#### Volume metrics

```{r fable_metrics, fig.show='hide'}
library(knitr)
par(margin = c(0,0,0,0), bty = "n")
## The volume
plot(trait_space, pch = defaults$pch, main = "", xlab = "", ylab = "")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1, lwd = 10)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1, lwd = 10)

## The volume
plot(trait_space, pch = defaults$pch, main = "", xlab = "", ylab = "")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1, lwd = 10)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1, lwd = 10)

```

<!-- 
some text | base|lattice
:------|:-------------------------------:|-------------------------------:
Some metric | $H_{0}: \Theta_{0} = \Theta$ | `r include_graphics(paste0(opts_chunk$get("fig.path"), "fable_metrics-1.png"), dpi = 800)`
Some other metric | $H_{0}: \Theta_{0} = \Theta$ | `r include_graphics(paste0(opts_chunk$get("fig.path"), "fable_metrics-2.png"), dpi = 800)`
Some other metric | $H_{0}: \Theta_{0} = \Theta$ | `r t.test(rnorm(10), distributions = rnorm(10))$p.value`
 -->


#### Density metrics


#### Position metrics



```{r, all_metric, echo = FALSE}
## All metrics (exploration)
metrics_list <- list(
    "av.pairwise" = function(matrix) return(mean(pairwise.dist(matrix)^2)),
    "Procrustes" = function(matrix) return(sum(matrix^2)/nrow(matrix)),
    "SoR" = c(sum, ranges),
    "SoV" = c(sum, variances),
    "PoQ" = c(prod, quantiles),
    "SoQ" = c(sum, quantiles),
    "av.displac" = c(mean, displacements),
    "av.neighbo" = c(mean, neighbours)
)

metric_names <- c("Average squared distance", "Procrustes variance", "Sum of Ranges", "Sum of Variances", "Product of Quantiles", "Sum of Quantiles", "Mean displacement", "Mean nearest neighbours distance")
```

```{r, complex_metrics_example, echo = FALSE, eval = FALSE}
complex_metric <- list("med.mana.dist.centre" = list(c(median, centroids),
                                                     centroid = 0, method = "manhattan"))
```

## Effect of dimensionality


In the end, the analysis should be a big GLM of

disparity ~ metric + reduction + dimensions + elements



# Results

  
```{r run_metrics, echo = FALSE, warning = FALSE}
## Toggle data generation or not
generate_data <- TRUE

if(generate_data) {
    set.seed(42)
    ## Bundle simulations 
    remove_05 <- simulation.spaces(remove = 0.5, replicates = 20, metrics_list = metrics_list)
    remove_08 <- simulation.spaces(remove = 0.8, replicates = 20, metrics_list = metrics_list)
    remove_02 <- simulation.spaces(remove = 0.8, replicates = 20, metrics_list = metrics_list)

    ## Save simulations
    save.results(remove_05)
    save.results(remove_08)
    save.results(remove_02)
} else {
    ## Load results
    remove_05 <- load.results("remove_05")
    remove_08 <- load.results("remove_08")
    remove_02 <- load.results("remove_02")
}

## Summarise the data
remove_05 <- lapply(remove_05, summarise.metrics)
remove_08 <- lapply(remove_08, summarise.metrics)
remove_02 <- lapply(remove_02, summarise.metrics)
```
 
## Results per space (05)

```{r fig_results_05, echo = FALSE, fig.height = 8, fig.width = 9}
## Plotting the results for 0.5
plot.metrics(remove_05, col = default.palette, remove = 0.5, defaults = defaults, text.in.cell = TRUE)
```

## Results per space (08)

```{r fig_results_08, echo = FALSE, fig.height = 8, fig.width = 9}
## Plotting the results for 0.8
plot.metrics(remove_08, col = default.palette, remove = 0.8, defaults = defaults, text.in.cell = TRUE)
```

## Results per space (02)

```{r fig_results_02, echo = FALSE, fig.height = 8, fig.width = 10}
## Plotting the results for 0.2
plot.metrics(remove_02, col = default.palette, remove = 0.2, defaults = defaults, text.in.cell = TRUE)
```

## Rarefaction

```{r run_rarefaction, echo = FALSE, warning = FALSE}
## Toggle data generation or not
generate_data <- TRUE

if(generate_data) {
    set.seed(42)
    ## Bundle simulations
    rarefy_05 <- simulation.rarefaction(remove = 0.5, replicates = 20, metrics_list = metrics_list)
    rarefy_08 <- simulation.rarefaction(remove = 0.8, replicates = 20, metrics_list = metrics_list)
    rarefy_02 <- simulation.rarefaction(remove = 0.2, replicates = 20, metrics_list = metrics_list)

    ## Save simulations
    save.results(rarefy_05)
    save.results(rarefy_08)
    save.results(rarefy_02)
} else {
    ## Load results
    load.results("rarefy_05")
    load.results("rarefy_08")
    load.results("rarefy_02")
}

## Summarise the data
rarefy_05 <- lapply(rarefy_05, summarise.metrics)
rarefy_08 <- lapply(rarefy_08, summarise.metrics)
rarefy_02 <- lapply(rarefy_02, summarise.metrics)
```

 
## Rarefied results for normal space (D = 50, remove 05)

```{r fig_results_05_rare, echo = FALSE, fig.height = 8, fig.width = 9}
## Plotting the results for 0.5
plot.metrics(rarefy_05, col = heat.colors, remove = 0.5, defaults = defaults, text.in.cell = TRUE)
```

## Results per space (08)

```{r fig_results_08_rare, echo = FALSE, fig.height = 8, fig.width = 9}
## Plotting the results for 0.8
plot.metrics(rarefy_08, col = heat.colors, remove = 0.8, defaults = defaults, text.in.cell = TRUE)
```

## Results per space (02)

```{r fig_results_02_rare, echo = FALSE, fig.height = 8, fig.width = 10}
## Plotting the results for 0.2
plot.metrics(rarefy_02, col = heat.colors, remove = 0.2, defaults = defaults, text.in.cell = TRUE)
```






















<!-- ## Alternative plotting (per results) -->

```{r fig_volume_results_unif2d05, echo = FALSE, fig.height = 21, fig.width = 8, eval = FALSE}
results <- summar_all_runif2d05
## Plotting the results
plot.results(results[[1]], results[[2]], col = default.palette(length(results[[1]])),
             space = typical_removal[[1]], remove_list = typical_removal[[2]], defaults)
```





<!-- ```{r fig_density_results, echo = FALSE, fig.height = 10, fig.width = 8, eval = FALSE}
results <- summar_den
## Plotting the results
plot.results(results[[1]], results[[2]], col = default.palette(length(results[[1]])),
             space = typical_removal[[1]], remove_list = typical_removal[[2]], defaults)
```

```{r fig_position_results, echo = FALSE, fig.height = 10, fig.width = 8, eval = FALSE}
results <- summar_pos
## Plotting the results
plot.results(results[[1]], results[[2]], col = default.palette(length(summar_vol[[1]])),
             space = typical_removal[[1]], remove_list = typical_removal[[2]], defaults)
```
 -->


## What do the metrics measure?



A Table with different metrics and the things tested: 1- What is it
capturing (size, position, density) 2- Effect of dimensionality 3-
Measuring the effect on tests

# Results


# Acknowledgements

Money from the ARC.

# References



# Supplementary material

## Algorithm for selecting the parameters to reduce the space ($radius$, $displacement$, $density$) {#Appendix_algorithm_reduce}

We used a recursive algorithm for selecting the parameter that removes $P$ elements: 80%, 50% or 20%.

1. Select a random reduction parameters $R$.
2. Remove elements from the space using $R$ resulting in $P'$ removed elements.
    If the remaining number of elements is to the required proportion $P$ ; exit the algorithm;
    Else go to 3.
3. Get the different between the proportion of removed elements $P'$ and $P$.
    If the difference is positive set the increment parameter $R$ to $R = 1.1 \times R$, then go to 2.
    Else set $R = 0.9 \times R$, then go to 2.

The algorithm is implemented in the `optimise.parameter` function in [reduce.space_fun.R](@@@).

