---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy?"
author: "Thomas Guillerme, Mark Puttick, Vera Weisbecker"
bibliography: references.bib
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 6
    fig_height: 6
    keep_tex: true
    self_contained: false
    line_numbers: true
    fig_caption: true
---


```{r header, echo = FALSE, results = 'hide', message = FALSE, warning = FALSE}
## Repeatability note:
## This whole paper is entirely reproducible and compiles as a single document. The data, figures
## and tables are all generated through the code snippets in this file. Note that the first time
## that this paper is compiled, it will generate the data which will take some substantial time
## by running the shiftingspace_supplementary.Rmd file first (~30 minutes). Subsequent compilations
## will be much faster!

## Loading the packages
library(knitr)
library(ape)
library(dispRity)
library(moms)

## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 ylim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait",
                 ylab = "Trait",
                 cex = 1)
## Generating the default palette
default.palette <- function(n) {
    hues = seq(15, 375, length = n + 1)
    grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}
```

# Abstract

Analysis of the diversity of morphological shapes (aka disparity analysis) are now a common toolkit in macroevolution.
Disparity analysis are based on the analysis of a morphospace (i.e. a multidimensional space summarising all possible shapes achieved or not) and a disparity metric (or index) to measure the occupancy of a group of taxa in that morphospace.
Such analysis have been commonly used to look at how a group of taxa changes through time, relatively to another group or as a response to some event (e.g. mass extinction).

However, disparity metrics are not often thoroughly described and thus can have a nebulous mathematical meaning.
This can make interpretation of changes in disparity often unclear beyond "a change in multidimensional space occupancy".
In fact, different aspect of spatial occupancy can be of interest in different studies.
For example, some questions might focus in changes in the volume of the morphospace whilst some other might focus on the position of a group in the morphospace or its density (or all three together).

Here we propose a user friendly tool to Measure Occupancy in Multidimensional Spaces (moms) that allows to visualise numerical changes of many disparity metrics following space transformations (e.g. contraction, displacement, etc.) as well as visualising a 2D projection of the associated space changes.
This tool thus allows researchers to explore and visualise the properties of disparity metrics under various parameters.
Furthermore, we propose a thorough review of the behaviour of seven common and two new disparity metrics regarding various spacial properties (i.e. distribution, transformation, dimensionality).
As expected, we found that different metrics are more appropriated to be used in different disparity analysis.

# Introduction


 * Disparity is used a lot since the 1990s [Definition blabla] and also in ecology
 * Although many definitions have been used in ecology (e.g. diversity of functional niches) or in evolution (e.g. diversity of morphological shapes), disparity is fundamentally a way to measure
 * It is linked to functional spaces in ecology (but not called disparity there)

 * Here we will try to approach both aspects (but more like macroevolution) by defining disparity as: "multidimensional trait-space occupancy".
 * In macroevolution, disparity is used to test hypothesis on how one or multiple groups occupy a morphospace (either through time or space or both)
 * It has been used to answer classical questions such as 1) does disparity of one group changes through time or in response to extinction or 2) do groups A and B have different disparity.

 * However, the problem is that it is unclear what is meant in these two questions: classically disparity has been measured as sum or product of ranges or variance.
 * This measures the "spread" of a group in a morphospace (the product of ranges is the hyper-rectangular volume) but many more aspects might be interesting to researchers.
 * For example, in 1) a group's disparity (e.g. sum of variance) might not change through time but it's density might (suggesting that the morphospace is more/less tightly packed); in 2) two groups's disparities (e.g. sum of ranges) might be different but they might be situated in the same region of the morphospace.
 * Here we are going to classify disparity metrics into two broad spatial occupancy categories that might change independently: the volume, the density and the position. All of them are a distribution of distance in the space (whether Euclidean, Manhattan or others) and are traditionally summarised into a central tendency (e.g. the **sum** of variances, the **mean** pairwise distance), etc...

 * Here we propose to test the effect of We will cite papers like this one [@disprity].



## Disparity metrics

```{r fig_metrics_types, echo = FALSE, fig.height = 3, fig.width = 9, results = 'hide', fig.cap = paste("Figure 1: different type of information captured by disparity metrics. A - Volume (e.g. sum of ranges); B - Density (e.g. average squared pairwise distances); C - Position (e.g. median distance from centroid).")}
set.seed(11)
## Plot space function (utility shortcut)
## The elements
elements <- 10

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)

## Graphical parameters
op <- par(mfrow = c(1,3), bty = "n")

## The volume
plot(trait_space, pch = defaults$pch, main = "A - Volume", xlab = "Trait 1", ylab = "Trait 2")
## The range lines
lines(x = range(trait_space[,1]), y = rep(mean(trait_space[,2]), 2), col = defaults$col1)
lines(x = rep(mean(trait_space[,1]), 2), y = range(trait_space[,2]), col = defaults$col1)

## The density
plot(trait_space, pch = defaults$pch, main = "B - Density", xlab = "Trait 1", ylab = "")
## Plotting the pairwise lines
pair.line <- function(line, trait_space, defaults) {
    lines(x = trait_space[line,1], y = trait_space[line,2], col = defaults$col1)
}
apply(combn(1:elements, 2), 2, pair.line, trait_space, defaults)
points(trait_space, pch = defaults$pch)

## The position
plot(trait_space, pch = defaults$pch, main = "C - Position", xlab = "Trait 1", ylab = "")
## Plotting the center of the space
points(0,0, pch = 13, cex = 2)
arrows(x0 = 0, y0 = 0, x1 = trait_space[,1], y1 = trait_space[,2], code = 0, col = defaults$col1)
points(trait_space, pch = defaults$pch)

par(op)
```

Disparity metrics (or indices) can capture different aspects of the multidimensional space occupancy.
The three fundamental informations that can be captured are:

#### 1. The volume

This type of metrics measures the spread of a group in the trait-space.
In biological terms, the bigger this metric, the more a group achieved more extreme morphologies.
This can be typically the hyper-volume, ellispsoid volume, product of ranges or product of variance.
This metric has widely been used since the advent of disparity analysis namely through the implementation of @Wills2001 in PAST or the Procrustes variance implemented in @adams2013geomorph (`geomorph::morphol.disparity`).

#### 2. The density

This type of metrics measures the "packness" of a group in the trait-space.
In biological terms, the bigger this metric, the more different elements are from each other.
This is typically measured by pairwise distances or nearest neigbhors distances.
In macroevolution, this metric is generally used in disparity-through-time analysis based on extant taxa as implemented in @geiger2008 (`geiger::dtt`).

#### 3. The position

This third type of metrics measures the particular position of the group in the morphospace, either relative to another group or relative to a fixed point in the morphospace.
The biological interpretation will thus depend on what the metrics measures the distance from.
For example if it's distance from the centre of the morphospace, the bigger the metric, the more "weird" (i.e. non-average) specimens in a group are (i.e. the centre being the average morphology in an ordination).
To our knowledge, this metric has been rarely used.

Of course, some metrics can be a combination of several of these three different and more.
In an ideal word, the choice of the metric should be based on the properties of changes in the morphospace of interest while taking into account the properties of the morphospace (number of elements or/and dimensions and distribution of the data on each axis).
However, it is highly unlikely that one such one-size-fits-all metric exists.
To alleviate this problem we suggest using multiple metrics.
For example, if the macroevolutionary question of interest is to look at how the morphospace changes in response to mass extinction, it is important to capture several expected effects through different metrics (e.g. a mass extinction making the specimens with extreme characteristics go extinct - e.g. big mammals in the megafauna extinction).

Finally, additionally to the fact that different metrics will capture different aspects of the morphospace, it is important to know how such metrics will change in response to predicted or observed changes in the morphospace.
For example, when measuring the volume of a morphospace, if the morphospace space decreases randomly by 50%, do we expect a reduction of the volume of 50% as well? Or merely a reduction in density?
In this paper, we thoroughly analyse the effect of such changes of the morphospace on five commonly used disparity metrics and propose two novel metrics.
We test both how these seven metrics change in response of different morphopace reduction scenarios but also how they respond to these changes depending on the space distributions and the number of dimensions.

We found no one-size-fits-all metric but provide guidance on which metric could be used in which specific scenario along with a new user friendly software with an intuitive graphical user interface (GUI) to look at the effect of changes in morphospace occupancy on user defined disparity metrics.

# Methods

To test the effect of spatial change (see Shifting space below), dimensions and dimensions distributions on the seven disparity metrics we:

 1. generated 7 different spaces with variable parameters
 2. transformed these spaces by removing 50% of the elements following four different scenarios
 3. measured disparity on the resulted transformed spaces

Each points are described in details below.

## Generating spaces

We generated 7 spaces using the following parameters:

| space name | size | distribution(s)                | dimensions variance | correlation |
|------------|------|--------------------------------|---------------------|-------------|
|   Uniform  |300*2 | Uniform (min = -0.5, max = 0.5)| Constant            | none        |
|   Uniform  |300*50| Uniform                        | Constant            | none        |
|   Uniform  |300*50| Uniform                        | Constant            | Random (between 0.1 and 0.9) |
|    Normal  |300*2 | Normal  (mean = 0, sd = 1)     | Constant            | none        |
|    Normal  |300*50| Normal                         | Constant            | none        |
|    Normal  |300*50| Normal                         | Constant            | Random (between 0.1 and 0.9) |
|   Random   |300*50| Normal, Uniform, Lognormal (meanlog = 0, sdlog = 1)| Constant            | none        |
| PCA-like   |300*50| Normal                         | Lognormal           | none        |
| PCO-like   |300*50| Normal                         | Normal              | none        |

Table 1: different simulated space distributions.

The five first spaces reflect specific distributions to understand the baseline effect of the metric on controlled variables.
The two last spaces (PCA and PCO-like) reflect spaces commonly used to measure changes in disparity in the macroevolutionary literature.

## Shifting spaces

We reduced the spaces by removing 50% of elements each time using the following algorithms


 * **Randomly:** by randomly removing 50% of elements.  Figure 2A.
  
 * **Limit:** by removing all elements with a distance from the centre (mean point) of the space lower or greater than a radius $\rho$ (where \$rho$ is selected such that 50% elements are selected).  Figure 2B.

 * **Displacement:** by removing points similarly as above but using the distance from the furthest point from the centre (max point). Figure 2C.

 * **Density:** by removing any pairs of point with a distance $D$ from each other where (where $D$ is selected such that 50% elements are selected). Figure 2D.

The algorithm to select $\rho$ or $D$ is described in more detail in in the [Appendix](#Appendix_algorithm_reduce).
We used mirror results for the limit, displacement and density reduction (i.e. the opposite data was also used).
For example, when increasing the **density** by removing the 50% most distant elements, we also run a transformation by removing 50% of the *closests* elements.
This resulted in seven different transformation by reducing the space: randomly, by limit (positive or negative), by displacement (positive or negative) or by density (increased or decreased).


```{r fig_reduce_space, echo = FALSE, fig.height = 8, fig.width = 8, results = 'hide', fig.cap = paste("Figure 2: different type of space reduction. Each panel displays 50% of the data points removed (in grey) using the following algorithm: A - randomly; B - by limit (removing data from the centre); C - by displacement (removing data from one side of the plot); and D - by density (removing data to increase or decrease the density).")}
set.seed(42)
op <- par(mfrow = c(2,2), bty = "n")
## The elements
elements <- 300
## The amount to remove
remove <- 0.5

## Trait space
trait_space <- space.maker(elements, 2, distribution = rnorm)
# ## The original space
# plot(trait_space, pch = 20, xlim = c(-3, 3), ylim = c(-3, 3),
#      main = "A - Original space", xlab = "Trait 1", ylab = "Trait 2")

## The randomly removed space
random_rm <- reduce.space(trait_space, type = "random", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, random_rm, main = "A - Random removal", defaults)

## The limit removal
limit_rm <- reduce.space(trait_space, type = "limit", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, limit_rm, main = "B - Limit", defaults)

## The displacement removal
displace_rm <- reduce.space(trait_space, type = "displacement", remove = 0.5)
## Moving the space to the upper right corner (positive)
plot.space(trait_space, displace_rm, main = "C - Displacement", defaults)

## The density removal
density_rm <- reduce.space(trait_space, type = "density", remove = 0.5)
## Plotting the reduction
plot.space(trait_space, density_rm, main = "D - Density", defaults)

## List of removals (for plotting the tables later)
typical_removal <- list(space = trait_space,
                        remove = list("random" = random_rm,
                                      "limit(min)" = limit_rm,
                                      "limit(max)" = !limit_rm,
                                      "displace(positive)" = displace_rm,
                                      "displace(negative)" = !displace_rm,
                                      "density(high)" = density_rm,
                                      "density(low)" = !density_rm))
```

We repeated each of the data generation process (generating the space and reducing it) 20 times to obtain variance on the simulated parameters.

## Disparity metrics

We then measured seven different metrics on the resulting transformed spaces:

Name          | Definition                      | Captures | Origin           | `dispRity` function
:-------------|:-------------------------------:|----------|------------------|------|
Average squared distance | $\left(\sqrt{\sum_{i}^{n}{({q}_{i}-p_{i})^2}}\right)^{2}\times \frac{1}{n}$ | Density and Volume | @geiger2008 | `mean(dispRity::pairwise.dist(matrix)^2)`
Procrustes variance | $\sum_{i}^{m=dn}{M_{m}^2} \times \frac{1}{d}$ | Density and Volume | @adams2013geomorph | `sum(matrix^2)/nrow(matrix)`
Ellipsoid volume | $\frac{\pi^{k/2}}{\Gamma(\frac{k}{2}+1)}\displaystyle\prod_{i=1}^{k} (\lambda_{i}^{0.5})$ | Volume | @DonohueDim | `dispRity::ellipse.volume(matrix)`
Product of ranges | $\prod_{i}^{d}{\|max(k_i) - min(k_i)\|}$ | Volume | @Wills2001 | `prod(dispRity::ranges(matrix))`
Sum of ranges | $\sum_{i}^{d}{\|max(k_i) - min(k_i)\|}$ | Volume | @Wills2001 | `sum(dispRity::ranges(matrix))`
Product of variances | $\prod_{i}^{d}{\sigma^{2}{k_i}}$ | Volume | @Wills2001 | `prod(dispRity::variances(matrix))`
Sum of variances | $\sum_{i}^{d}{\sigma^{2}{k_i}}$ | Volume | @Wills2001 | `sum(dispRity::variances(matrix))`
Average displacement | $\frac{\sqrt{\sum_{i}^{n}{({k}_{n})^2}}}{\sqrt{\sum_{i}^{n}{({k}_{n}-Centroid_{k})^2}}}$ | Position | This paper | `mean(dispRity::displacements(matrix))`
Average nearest neighbour distance |$min\left(\sqrt{\sum_{i}^{n}{({q}_{i}-p_{i})^2}}\right)\times \frac{1}{n}$ | Density | This paper | `mean(dispRity::neighbours(matrix))`


```{r, all_metric, echo = FALSE}
## All metrics (exploration)
metrics_list <- list(
    "av.pairwise" = function(matrix) return(mean(pairwise.dist(matrix)^2)),
    "Procrustes" = function(matrix) return(sum(matrix^2)/nrow(matrix)),
    "Volume" = ellipse.volume,
    "PoR" = c(prod, ranges),
    "SoR" = c(sum, ranges),
    "PoV" = c(prod, variances),
    "SoV" = c(sum, variances),
    # "PoQ" = c(prod, quantiles),
    # "SoQ" = c(sum, quantiles),
    "av.displac" = c(mean, displacements),
    "av.neighbo" = c(mean, neighbours)
)

metric_names <- c("Average squared distance", "Procrustes variance", "Ellipsoid volume", 
                  "Product of Range", "Sum of Ranges", "Product of Variances", "Sum of Variances",
                  "Mean displacement", "Mean nearest neighbours distance")
## Shorter vector name version (for clarity in the fable)
name <- metric_names
#"Product of Quantiles", "Sum of Quantiles", 
```

```{r, complex_metrics_example, echo = FALSE, eval = FALSE}
complex_metric <- list("med.mana.dist.centre" = list(c(median, centroids),
                                                     centroid = 0, method = "manhattan"))
```

## Effect of dimensionality

Furthermore, high dimensional spaces ($>> 3$) are subject to the "curse of multidimensionality" [@cursedimensionality].
This is link to the fact that the more dimensions, the more sparse the data becomes.
In other words the probability of two points A and B overlapping in *n* dimensions is the probability of point A having the same value as point point B on dimension 1, 2, 3, etc...
Thus this probability decreases as a product of the number of dimensions.
This "curse" can make the interpretation of high dimensional data counter-intuitive.

For example, the product of range is expected to decrease with the number of dimensions, regardless of the number of elements on each dimensions.
This is counter-intuitive because:
1) first, the range of values on a dimension is bounded to the number of elements on this dimensions (i.e. increasing the number of observations on one dimension can only increase the range, never decrease it);
2) second, products are a classical example of the "curse" where multiplying a higher number of dimensions with a non-null probability of having a range of zero will irremediably result in 0 (i.e. an infinite number of positive values by 0 is still 0).


```{r fig_curse, echo = FALSE, fig.height = 8, fig.width = 8, results = 'hide', fig.cap = paste("Figure 3: Effect of the curse of dimensionality on different scaled disparity metrics. Metrics with containing products (ellipsoid volume, product of ranges or variances) are classically affected by the \"curse\" as they decrease more or less rapidly with an increase in dimensions. Note especially how the Product of Range actually increases and then decreases with the number of dimensions.")}
set.seed(42)
## Make a 50 dimensions space
space <- space.maker(300, 50, rnorm, scree = rev(cumsum(rep(1/50, 50))))

## Function wrappers
disparity <- function(metric, dimensions, space) {
    fast.disparity(group = 1:nrow(space), space = space, metric = metric, rare.dim = dimensions)
}
lapply.fun <- function(dimensions, metrics_list, space) {
  unlist(lapply(metrics_list, disparity, dimensions = dimensions, space = space))
}

## Curse results
curse_results <- sapply(2:50, lapply.fun, metrics_list = metrics_list, space = space)
curse_results <- apply(curse_results, 1, function(x) return(x/max(x)))

## Empty plot
hue_colors <- default.palette(ncol(curse_results))
par(bty = "n")
plot(NULL, xlim = c(2,50), ylim = c(0,1),
    xlab = "Dimensions (decreasing variance)",
    ylab = "Scaled disparity")
for(metric in 1:ncol(curse_results)) {
  lines(curse_results[, metric], col = hue_colors[metric])
}
legend("bottomleft", metric_names, lty = 1, col = hue_colors)
```

## Measuring the effect of space reduction, distribution and dimensionality on the metric

### Scaling disparity

To measure the effect of space reduction, distribution and dimensionality on the metric, we first scaled the metric to be relative to the non reduced space for each dimension distributions or number of dimensions.
To do so, we subtracted the observed disparity with no space reduction (i.e. base disparity) to all the disparity measurements of the reduced spaces and then divided it by the resulting maximum observed disparity.
This way, our disparity metrics where scaled between -1 and 1 with a value of 0 indicating no effect of the space reduction and $>0$ and $<0$ respectively indicating an increase or decrease in the disparity metric value.

### Measuring the effect of the metric

TODO: probably simply do a Bhattacharyya coefficient to see how much the disparity from the reduced space overlaps with the randomly reduced disparity.
High values will indicate low effect and low values, high effects.
TODO: probably flip that metric over so that low values = low effects and high values = high effects

$\text{Effect of metric} = 1 - BC(metric_{focal}, metric_{random})$

### Measuring the effect of space and dimensionality

To measure the effect of the different space distributions 

# Results

```{r loading_results, echo = FALSE}
## Loading the results
remove_05 <- load.results("remove_05")
rarefy_dim_05 <- load.results("rarefy_dim_05")
```

```{r running_tests, echo = FALSE}
## Anova function
anova.fun <- function(data) {return(aov(glm(disparity ~ factor, data = data)))}

## Running the tests
test_space05 <- test.metrics(remove_05, test = anova.fun, scale = TRUE)
test_raref05 <- test.metrics(rarefy_dim_05, test = anova.fun, scale = TRUE)

#TODO: Generate the aov tables in the supplementary

```

```{r fable_results, fig.show='hide', echo=FALSE, fig.height=1.5, fig.width=1.5}
## Making a list of parameters for each mini plot
plot.param <- list(scaler = 0.5,
                   bg.col = "black",
                   col = c("grey", "orange", "blue"),
                   quantiles = c(95, 50),
                   cent.tend = median,
                   pch = 19)

## Looping through each mini plot for every metric
for(metric in 1:length(metrics_list)) {
    generate.fable.plot(data = remove_05, metric = metric, what = "limits", plot.param = plot.param)
    generate.fable.plot(data = remove_05, metric = metric, what = "displa", plot.param = plot.param)
    generate.fable.plot(data = remove_05, metric = metric, what = "densit", plot.param = plot.param)
}

```

Metric      | Volume change  | Position change | Density change | Distribution effect | Dimensions effect
:-----------|----------------|-----------------|----------------|---------------------|-------------------
`r name[1]` |`r plot.id(1)`  |`r plot.id(2)`   |`r plot.id(3)`  | `r s.test(1, "s")`  | `r s.test(1, "r")`
`r name[2]` |`r plot.id(4)`  |`r plot.id(5)`   |`r plot.id(6)`  | `r s.test(2, "s")`  | `r s.test(2, "r")`
`r name[3]` |`r plot.id(7)`  |`r plot.id(8)`   |`r plot.id(9)`  | `r s.test(3, "s")`  | `r s.test(3, "r")`
`r name[4]` |`r plot.id(10)` |`r plot.id(11)`  |`r plot.id(12)` | `r s.test(4, "s")`  | `r s.test(4, "r")`
`r name[5]` |`r plot.id(13)` |`r plot.id(14)`  |`r plot.id(15)` | `r s.test(5, "s")`  | `r s.test(5, "r")`
`r name[6]` |`r plot.id(16)` |`r plot.id(17)`  |`r plot.id(18)` | `r s.test(6, "s")`  | `r s.test(6, "r")`
`r name[7]` |`r plot.id(19)` |`r plot.id(20)`  |`r plot.id(21)` | `r s.test(7, "s")`  | `r s.test(7, "r")`
`r name[8]` |`r plot.id(22)` |`r plot.id(23)`  |`r plot.id(24)` | `r s.test(8, "s")`  | `r s.test(8, "r")`
`r name[9]` |`r plot.id(25)` |`r plot.id(26)`  |`r plot.id(27)` | `r s.test(9, "s")`  | `r s.test(9, "r")`


## Stats

Check whether a metric changes:

1 - By reduction (i.e. whether the resulting metric is positive or negative)
2 - By space (i.e. whether the metric is constant for different spaces)
3 - By dimensions (i.e. whether the metric is constant for different number of dimensions)



## What do the metrics measure?



A Table with different metrics and the things tested: 1- What is it
capturing (size, position, density) 2- Effect of dimensionality 3-
Measuring the effect on tests

# Results


# Acknowledgements

Money from the ARC.




# References





# Supplementary material

## Algorithm for selecting the parameters to reduce the space ($radius$, $displacement$, $density$) {#Appendix_algorithm_reduce}

We used a recursive algorithm for selecting the parameter that removes $P$ elements: 80%, 50% or 20%.

1. Select a random reduction parameters $R$.
2. Remove elements from the space using $R$ resulting in $P'$ removed elements.
    If the remaining number of elements is to the required proportion $P$ ; exit the algorithm;
    Else go to 3.
3. Get the different between the proportion of removed elements $P'$ and $P$.
    If the difference is positive set the increment parameter $R$ to $R = 1.1 \times R$, then go to 2.
    Else set $R = 0.9 \times R$, then go to 2.

The algorithm is implemented in the `optimise.parameter` function in [reduce.space_fun.R](@@@).

