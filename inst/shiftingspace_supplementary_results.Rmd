---
title: "Shifting spaces: how to summarise multidimensional spaces occupancy?"
author: "Thomas Guillerme, Mark Puttick, Ariel Marcy, Vera Weisbecker"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

# Supplementary material 3: supplementary results
 
```{r, echo = FALSE}
## Loading the packages
if(!require(devtools)) install.packages("devtools")
if(!require(knitr)) install.packages("knitr"); library(knitr)
if(!require(rmarkdown)) install.packages("rmarkdown"); library(rmarkdown)
if(!require(ape)) install.packages("ape"); library(ape)
if(!require(dispRity)) install.packages("dispRity"); library(dispRity)
if(packageVersion("dispRity") < "1.2.4") {
    ## dispRity must be above v1.2.3
    devtools::install_github("TGuillerme/dispRity"); library(dispRity)
}
if(!require(moms)) devtools::install_github("TGuillerm/moms"); library(moms)

## Setting the default parameters for the space plots
defaults <- list(pch = 20,
                 xlim = c(-3, 3),
                 ylim = c(-3, 3),
                 col1 = "grey",
                 col2 = "black",
                 xlab = "Trait",
                 ylab = "Trait",
                 cex = 1)
## Generating the default palette
default.palette <- function(n) {
    hues = seq(15, 375, length = n + 1)
    grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}
```

## ANOVA tables

```{r loading_results, echo = FALSE}
## Loading the results
remove_05 <- load.results("remove_05")
```

```{r running_tests, echo = FALSE}
## Anova function
anova.fun <- function(data) {return(aov(glm(disparity ~ factor, data = data)))}

## Running the tests
all_test <- test.simulation(remove_05, test = anova.fun, scale = TRUE)
all_dim_test <- test.simulation(remove_05, test = anova.fun, scale = TRUE,
                      factors = c("uniform3", "uniform15", "uniform50", "uniform100", "uniform150",
                                  "normal3", "normal15", "normal50", "normal100", "normal150"))
dim_unif_test <- test.simulation(remove_05, test = anova.fun, scale = TRUE,
                      factors = c("uniform3", "uniform15", "uniform50", "uniform100", "uniform150"))
dim_norm_test <- test.simulation(remove_05, test = anova.fun, scale = TRUE,
                      factors = c("normal3", "normal15", "normal50", "normal100", "normal150"))
space_test <- test.simulation(remove_05, test = anova.fun, scale = TRUE,
                              factors = c("uniform50", "uniform50c", "normal50", "normal50c",
                                          "random50", "pca_like", "pco_like"))
```

```{r, echo = FALSE}
## Function for converting the results into a table
convert.to.table <- function(results, factor) {

    ## Make the empty data.frame
    output <- matrix("", nrow = length(results)*2, ncol = dim(results[[1]][[1]])[2]+2,
                     dimnames = list(c(), c("metric", "", colnames(results[[1]][[1]]))))
    ## Fill the table with the metric names
    output[,1] <- c(rbind(names(results), rep("", length(results))))
    output[,2] <- rep(c(factor, "Residuals"), length(results))

    ## Printing sequence
    print_seq <- rep(seq(1:length(results)), each = 2)

    ## Printing each results
    for(one_table in seq(from = 1, to = length(results)*2, by = 2)) {
        as.matrix(results[[print_seq[one_table]]][[1]]) -> 
            output[one_table:(one_table+1), (1:dim(results[[print_seq[one_table]]][[1]])[2])+2] 
    }

    ## Coerce to data.frame
    output <- as.data.frame(output, stringsAsFactors = FALSE)
    output[, -c(1:2)] <- apply(output[, -c(1:2)], 2, as.numeric)
    colnames(output)[2] <- ""
    return(output)
}
```

```{r, echo = FALSE}
kable(convert.to.table(all_test, factor = "all spaces"), digits = 3,
     caption = "ANOVA results caption")
```

```{r, echo = FALSE}
kable(convert.to.table(all_dim_test, factor = "dimensions"), digits = 3,
     caption = "ANOVA results caption")
```

```{r, echo = FALSE}
kable(convert.to.table(dim_unif_test, factor = "dimensions (uniform)"), digits = 3,
     caption = "ANOVA results caption")
```

```{r, echo = FALSE}
kable(convert.to.table(dim_norm_test, factor = "dimensions (normal)"), digits = 3,
     caption = "ANOVA results caption")
```

```{r, echo = FALSE}
kable(convert.to.table(space_test, factor = "space type"), digits = 3,
     caption = "ANOVA results caption")
```

# Metrics similarity

This section details the similarity between certain categories of metrics

## Methods

We generate a series of 7 spaces of 50 dimensions replicated 10 times (see the main manuscript for details on the procedure).

| space name | size  | distribution(s)                | dimensions variance | correlation |
|------------|-------|--------------------------------|---------------------|-------------|
| Uniform50  |200*50 | Uniform                        | Constant            | none        |
| Uniform50c |200*50 | Uniform                        | Constant            | Random (between 0.1 and 0.9) |
| Normal50   |200*50 | Normal                         | Constant            | none        |
| Normal50c  |200*50 | Normal                         | Constant            | Random (between 0.1 and 0.9) |
| Random     |200*50 | Normal, Uniform, Lognormal     | Constant            | none        |
| PCA-like   |200*50 | Normal                         | Lognormal           | none        |
| PCO-like   |200*50 | Normal                         | Normal              | none        |

```{r simulate_spaces, echo = FALSE, warning = FALSE, results = 'hide'}
set.seed(42)
## List of distributions
distributions_list <- list(
    "unifor" = list(distribution = runif, arguments = list(list("min" = -0.5, "max" = 0.5))),
    "normal" = list(distribution = rnorm),
    "random" = list(distribution = "random"),
    "unicor" = list(distribution = runif, arguments = list(list("min" = -0.5, "max" = 0.5)),
                    cor.matrix = "random"),
    "norcor" = list(distribution = rnorm, cor.matrix = "random"),
    "pcalik" = list(distribution = rnorm, scree = "lognormal"),
    "pcolik" = list(distribution = rnorm, scree = "normal")
    )

## Number of replicates (low on purpose!)
n_replicates <- 10

## Number of elements
elements <- function() 200

## Generating all spaces
all_spaces <- list(uniform50 = space.simulation(distributions_list$unifor, dimensions = 50,
                                               elements = elements(), replicates = n_replicates),
                   uniformc50 = space.simulation(distributions_list$unicor, dimensions = 50,
                                               elements = elements(), replicates = n_replicates),
                   normal50 = space.simulation(distributions_list$normal, dimensions = 50,
                                               elements = elements(), replicates = n_replicates),
                   normalc50 = space.simulation(distributions_list$norcor, dimensions = 50,
                                               elements = elements(), replicates = n_replicates),
                   random50 = space.simulation(distributions_list$random, dimensions = 50,
                                               elements = elements(), replicates = n_replicates),
                   pca_like = space.simulation(distributions_list$pcalik, dimensions = 50,
                                               elements = elements(), replicates = n_replicates),
                   pco_like = space.simulation(distributions_list$pcolik, dimensions = 50,
                                               elements = elements(), replicates = n_replicates))

```

We then calculated space occupancy with the following metrics:

Name          | Definition                      | Captures | Origin           | `dispRity` function
:-------------|:-------------------------------:|----------|------------------|------|
Average squared distance | $\left(\sqrt{\sum_{i}^{n}{({q}_{i}-p_{i})^2}}\right)^{2}\times \frac{1}{n}$ | Volume | @geiger2008 | `mean(dispRity::pairwise.dist(matrix)^2)`
Procrustes variance | $\sum_{i}^{m=dn}{M_{m}^2} \times \frac{1}{d}$ | Volume | @adams2013geomorph | `sum(matrix^2)/nrow(matrix)`
Functional dispersion | $\frac{\sqrt{\sum_{i}^{n}{({k}_{n}-Centroid_{k})^2}}{n}$ | Volume and density | Volume | @lalibertÃ©2010 | |
Ellipsoid volume | $\frac{\pi^{k/2}}{\Gamma(\frac{k}{2}+1)}\displaystyle\prod_{i=1}^{k} (\lambda_{i}^{0.5})$ | Volume | @donohue2013 | `dispRity::ellipse.volume(matrix)`
Prod of variances | $\sum_{i}^{d}{\sigma^{2}{k_i}}$ | Volume | @wills2001 | `prod(dispRity::variances(matrix))`
Prod of ranges | $\sum_{i}^{d}{\sigma^{2}{k_i}}$ | Volume | @wills2001 | `prod(dispRity::ranges(matrix))`
Prod of quantiles | | Volume |  | `prod(dispRity::quantiles(matrix))` 
Sum of variances | $\sum_{i}^{d}{\sigma^{2}{k_i}}$ | Volume | @wills2001 | `sum(dispRity::variances(matrix))`
Sum of ranges | $\sum_{i}^{d}{\sigma^{2}{k_i}}$ | Volume | @wills2001 | `sum(dispRity::ranges(matrix))`
Sum of quantiles | | Volume |  | `sum(dispRity::quantiles(matrix))` 


```{r, eval = TRUE, echo = FALSE}
source("list.of.metrics.R")
## General volume metrics
volume_metrics <- list("av.pairwise" = function(matrix) return(mean(pairwise.dist(matrix)^2)),
                       "Procrustes"  = function(matrix) return(sum(matrix^2)/nrow(matrix)),
                       "func.disp"   = func.disp,
                       "sum.var"    = c(sum, variances),
                       "sum.ranges" = c(sum, ranges),
                       "sum.quantil"= c(sum, quantiles),
                       "prod.var"    = c(prod, variances),
                       "prod.ranges" = c(prod, ranges),
                       "prod.quantil"= c(prod, quantiles),
                       "ellips.vol"  = ellipse.volume,
                       "n.ball.vol"  = n.ball.volume)
volume_names <- c("Average squared pairwise distance",
                  "Procrustes variances",
                  "Functional dispersion",
                  "Sum of variances",
                  "Sum of ranges",
                  "Sum of quantiles",
                  "Product of variances",
                  "Product of ranges",
                  "Product of quantiles",
                  "Ellipsoid volume",
                  "nBall volume"
                  )

## General density metrics
density_metrics <- list("span.tree"   = span.tree.length,
                       "ave.neigh"   = c(mean, neighbours),
                       "ave.pairdist"= c(mean, pairwise.dist))
density_names <- c("Minimum spanning tree length",
                  "Average minimum neighbours distance",
                  "Average pairwise distance")

## General position metrics
position_metrics <- list("func.div" = func.div,
                       "av.displa"  = c(mean, displacements))
position_names <- c("Function diversity",
                  "Average displacement")

## Functional metrics
functional_metrics <- list("func.div" = func.div,
                           "func.eve" = func.eve,
                           "func.disp" = func.disp)
functional_names <- c("Functional diversity",
                    "Functional evenness",
                    "Functional dispersion")

## Selected metrics
select_metrics <- list("func.disp" = func.disp,
                       "sum.var"    = c(sum, variances),
                       "ellips.vol" = ellipse.volume,
                       "span.tree"  = function(matrix) span.tree.length(matrix)/nrow(matrix),
                       "ave.neigh"  = c(mean, neighbours),
                       "av.displa"  = c(mean, displacements),
                       "med.centre" = function(matrix) median(centroids(matrix, centroid = 0)))
```

```{r get_disparity_volume, echo = FALSE, warning = FALSE, results = 'hide'}
## Lapply functions to get disparity
lapply.disparity <- function(one_space, one_metric) {
    space_dim <- dim(one_space)
    return(fast.disparity(rep(TRUE, space_dim[1]), one_space, one_metric, rare.dim =  space_dim[2]))
}
lapply.metric <- function(one_metric, space) {
    return(matrix(lapply(space, lapply.disparity, one_metric), nrow = 1, dimnames = list("all")))
}
lapply.space <- function(space, metrics) {
    return(lapply(metrics, lapply.metric, space))
}

## Get the results for the volume
volume_results <- lapply(all_spaces, lapply.space, volume_metrics)
## Get the results for the density
density_results <- lapply(all_spaces, lapply.space, density_metrics)
## Get the results for the position
position_results <- lapply(all_spaces, lapply.space, position_metrics)
## Get the results for the functional
functional_results <- lapply(all_spaces, lapply.space, functional_metrics)
## Get the results for the selected
select_results <- lapply(all_spaces, lapply.space, select_metrics)
```

## Results

### Volume metrics

```{r, echo = FALSE}
results_pairwise <- volume_results

## Printing the results
names(results_pairwise[[1]]) <- gsub(" ", "\n", volume_names)

## Plotting the pairwise results
pairwise.plot(results_pairwise, scale = TRUE, type = "base", plot = "cor")
```

### Density metrics

```{r, echo = FALSE}
results_pairwise <- density_results

## Printing the results
names(results_pairwise[[1]]) <- gsub(" ", "\n", density_names)

## Plotting the pairwise results
pairwise.plot(results_pairwise, scale = TRUE, type = "base", plot = "cor")
```

### Position metrics

```{r, echo = FALSE}
results_pairwise <- position_results

## Printing the results
names(results_pairwise[[1]]) <- gsub(" ", "\n", position_names)

## Plotting the pairwise results
pairwise.plot(results_pairwise, scale = TRUE, type = "base", plot = "cor")
```

### functional metrics

```{r, echo = FALSE}
results_pairwise <- functional_results

## Printing the results
names(results_pairwise[[1]]) <- gsub(" ", "\n", functional_names)

## Plotting the pairwise results
pairwise.plot(results_pairwise, scale = TRUE, type = "base", plot = "cor")
```

### select metrics

```{r, echo = FALSE}
results_pairwise <- select_results

## Printing the results
names(results_pairwise[[1]]) <- gsub(" ", "\n", select_names)

## Plotting the pairwise results
pairwise.plot(results_pairwise, scale = TRUE, type = "base", plot = "cor")
```